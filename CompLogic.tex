% !TeX spellcheck = en_US
\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz,tkz-euclide}
\usepackage{titlesec}
\usepackage{gensymb}
\usepackage{textcomp}
\usepackage[titles]{tocloft}
\usepackage{csquotes}
\usepackage[babel]{microtype}
\usepackage{MnSymbol}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{ulem}
\usepackage[shortlabels]{enumitem}
\usepackage{scalerel}
\usepackage{stackengine}
\usepackage[
  separate-uncertainty = true,
  multi-part-units = repeat
]{siunitx}

\usetkzobj{all}
\usetikzlibrary{shapes.misc}

\MakeOuterQuote{"}

\setcounter{secnumdepth}{4}

\renewcommand\hateq{\mathrel{\stackon[1.5pt]{=}{\stretchto{%
				\scalerel*[\widthof{=}]{\wedge}{\rule{1ex}{3ex}}}{0.5ex}}}}

\newcommand*\circled[1]{
  \tikz[baseline=(C.base)]\node[draw,circle,inner sep=0.75pt](C) {#1};\!
}

\newcommand*{\obot}{\perp\mkern-20.7mu\bigcirc}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\DeclarePairedDelimiter\norm{\lVert}{\rVert}
\makeatletter
\let\oldabs\abs
\def\abs{\@ifstar{\oldabs}{\oldabs*}}
\let\oldnorm\norm
\def\norm{\@ifstar{\oldnorm}{\oldnorm*}}
\makeatother

\renewcommand{\thesubsection}{\arabic{subsection}}
\titleformat{\section}{\normalfont\Large\bfseries}{§\arabic{section}: }{0em}{}
\titleformat{\subsection}{\normalfont\large\bfseries}{§\arabic{subsection} }{0em}{}
\titleformat{\subsubsection}{\normalfont\bfseries}{\arabic{subsection}.\arabic{subsubsection} }{0em}{}
\renewcommand{\cftsubsecpresnum}{§}
\newlength\mylength
\settowidth\mylength{\cftsubsecpresnum}
\settowidth\mylength{\cftsubsecaftersnum}
\addtolength\cftsubsecnumwidth{\mylength}
\renewcommand{\cftsecpresnum}{§}
\renewcommand{\cftsecaftersnum}{: }
\settowidth\mylength{\cftsecpresnum}
\addtolength\cftsecnumwidth{\mylength}

\newcommand{\ul}{\underline}
\renewcommand{\proof}{\ul{Beweis:}\\}
\renewcommand{\qed}{\begin{flushright}
\ul{\(q.e.d.\)}
\end{flushright}}
\let\origphi\phi
\let\phi\varphi
\let\origepsilon\epsilon
\let\epsilon\varepsilon

\title{Computational Logic}
\author{Nico Mexis}
\date{\today}

\begin{document}
\maketitle
\newpage

\tableofcontents
\newpage

\section{What is logic?}
\ul{Logical Statement:} Sentence/proposition, which evaluates to $TRUE$ or $FALSE$\\
\ul{Logical connectives:} If $A$ and $B$ are logical statements, then $A\wedge B$ is another one\\
\ul{Logical system:}
\begin{enumerate}[(1)]
	\item \ul{Syntax:}
	\begin{itemize}
		\item Atomic formulas are connected by operations
		\item There is a set of rules, which tell you, if the formula is well-formed
	\end{itemize}
	\item \ul{Semantics:}
	\begin{itemize}
		\item There is a set of rules, which tell you, how to assign truth values to formulas, given the values of the atomic formulas
	\end{itemize}
	\item \ul{Logical calculus:}
	\begin{itemize}
		\item Always $TRUE$: Tautology
		\item Always $FALSE$: Unsatisfiable
		\item Sometimes $TRUE$: Satisfiable
		\item There is a set of rules such that, given a formula $F$ and an assignment for the truth values of the atomic formulas, it calculates the truth value of $F$.
		\item The algorithm should be able to decide if $F$ is a tautology/satisfiable
	\end{itemize}
\end{enumerate}
\section{Propositional Logic}
\ul{Syntax}:
Atomic formulas are called \ul{propositions} denoted by $A_0,A_1,\dots$ (or $A,B,C,\dots$)\\
A \ul{formula} in propositional logic is obtained by recursively applying the following rules:
\begin{enumerate}[(1)]
	\item An atomic formula is a formula
	\item Given a formula $F$, also $\neg F$ is a formula ("not $F$")
	\item Given two formulas $F,G$, also $F\wedge G$ ("$F$ and $G$") and $F\vee G$ ("$F$ or $G$") are formulas
\end{enumerate}
Let $F,G$ be formulas.
\begin{enumerate}[(a)]
	\item Instead of $\neg F\vee G$, we also write $F\Rightarrow G$ ("$F$ implies $G$")
	\item Instead of $(\neg F\vee G)\wedge (F\vee \neg G)$ we also write $F\Leftrightarrow G$ ("$F$ is equivalent to $G$")
	\item Instead of $F_1\wedge\dots\wedge F_n$ we also write $\bigwedge_{i=1}^n F_i$ and instead of $F_1\vee\dots\vee F_n$ also $\bigvee_{i=1}^n F_i$
\end{enumerate}
\ul{Semantics}:
\begin{enumerate}[(a)]
	\item The set of truth values is $\{0,1\}$, where 0 is $FALSE$ and 1 is $TRUE$
	\item Let $M$ be a set of atomic formulas. A map $\alpha:M\rightarrow\{0,1\}$ is called a \ul{truth assignment}
	\item Let $\hat{M}$ be the set of all formulas in which only propositions of $M$ appear.\\
	Then we define $\hat{\alpha}:\hat{M}\rightarrow\{0,1\}$ recursively as follows:
	\begin{enumerate}[(1)]
		\item If $A\in M$, then we let $\hat{\alpha}(A)=\alpha(A)$
		\item If $\alpha(F)$ is defined, then we let $\hat{\alpha}(\neg F)=1-\hat{\alpha}(F)$
		\item Given formulas $F,G$ for which $\hat{\alpha}(F),\hat{\alpha}(G)$ have been defined, we let $\hat{\alpha}(F\wedge G)=\begin{cases}
		1, & \text{if } \hat{\alpha}(F)=\hat{\alpha}(G)=1\\
		0, & \text{otherwise}
		\end{cases}$ and $\hat{\alpha}(F\vee G)=\begin{cases}
		1, & \text{if } \hat{\alpha}(F)=1 \text{ or } \hat{\alpha}(G)=1 \text{ or both}\\
		0, & \text{if } \hat{\alpha}(F)=\hat{\alpha}(G)=1
		\end{cases}$
	\end{enumerate}
\end{enumerate}
\begin{tabular}{ll}
$F$ "if" $G$ & $\hateq$ $G\Rightarrow F$\\
$F$ "only if" $G$ & $\hateq$ $F\Rightarrow G$\\
$F$ "if and only if" $G$ & $\hateq$ $F\Leftrightarrow G$\\
\end{tabular}\\
Let $F$ be a (propositional logic) formula, $M$ a set of propositions and $\alpha:M\rightarrow\{0,1\}$ a truth assignment.
\begin{enumerate}[(a)]
	\item The formula $F$ \ul{fits} with $\alpha$ or $\alpha$ is \ul{suitable} for $F$ if in $F$ only the propositions from $M$ appear.
	\item If $\alpha(F)=1$, then $F$ is called a \ul{model} for $\alpha$. We write $\alpha\models F$.
	\item Given a set of formulas $\mathcal{F}$, we write $\alpha\models \mathcal{F}$ if $\alpha\models F$ for every $F\in\mathcal{F}$.
	\item We say that $F$ is \ul{satisfiable} if there exists a truth assignment $\alpha$, which is suitable for $F$ and if $\alpha(F)=1$. Otherwise, we say that $F$ is \ul{unsatisfiable}.
	\item A formula $F$ is called a \ul{tautology} (or \ul{valid}) if $\alpha(F)=1$ for every suitable truth assignment $\alpha$.
\end{enumerate}
A formula $F$ is a \ul{tautology} if and only if $\neg F$ is unsatisfiable.\\
Two formulas $F,G$ are called \ul{(semantically) equivalent}, if for all truth assignments $\alpha$, which are suitable for both $F$ and $G$, we have $\alpha(F)=\alpha(G)$. Notation: $F\equiv G$\\
\ul{The Fundamental Equivalences:}
Let $F,G,H$ be formulas.
\begin{enumerate}[(a)]
	\item $F\wedge F\equiv F$ and $F\vee F\equiv F$ (idempotency)
	\item $F\wedge G\equiv G\wedge F$ and $F\vee G\equiv G\vee F$ (commutativity)
	\item $(F\wedge G)\wedge H\equiv F\wedge(G\wedge H)$ and\\
	$(F\vee G)\vee H\equiv F\vee (G\vee H)$ (associativity)\\
	Hence we write $F_1\wedge\dots\wedge F_n$ or $F_1\vee \dots\vee F_n$.
	\item $F\wedge(F\vee G)\equiv F$ and $F\vee(F\wedge G)\equiv F$ (absorption)
	\item $F\wedge(G\vee H)\equiv (F\wedge G)\vee(F\wedge H)$ and\\
	$F\vee(G\wedge H)\equiv (F\vee G)\wedge(F\vee H)$ (distributive law)
	\item $\neg$$\neg F\equiv F$
	\item $\neg(F\wedge G)\equiv \neg F\vee \neg G$ and\\
	$\neg(F\vee G)\equiv \neg F\wedge \neg G$ (de Morgan's rules)
	\item If $F$ is a tautology, then $F\vee G\equiv F$ and $F\wedge G\equiv G$
	\item If $F$ is unsatisfiable, then $F\vee G\equiv G$ and $F\wedge G\equiv F$
\end{enumerate}
\ul{Substitution Theorem}:\\
Let $F_1,F_2$ be two equivalent formulas.\\
Let $G$ be a formula, which contains $F_1$ as a subformula.\\
Let $\tilde{G}$ be the formula obtained by replacing $F_1$ in $G$ by $F_2$.\\
Then we have $G\equiv \tilde{G}$.
\begin{enumerate}[(a)]
	\item A \ul{literal} is an atomic formula or the negation of an atomic formula ($A_i$ or $\neg A_i$)
	\item A formula $F$ is said to be in \ul{conjunctive normal form} (CNF), if it is of the form $$F=(L_{11}\vee L_{12}\vee\dots\vee L_{1n_1})\wedge\dots\wedge(L_{k1}\vee L_{k2}\vee\dots\vee L_{kn_k})$$ where the $L_{ij}$ are literals ("$F$ is a conjunction of disjunctions of literals").
	\item We say that $F$ is in \ul{disjunctive normal form} (DNF) if $$F=(L_{11}\wedge L_{12}\wedge\dots\wedge L_{1n_1})\vee\dots\vee(L_{k1}\wedge L_{k2}\wedge\dots\wedge L_{kn_k})$$ with literals $L_{ij}$.
\end{enumerate}
\ul{Algorithm:}\\
Let $F$ be a formula. Consider the following sequence of instructions:
\begin{enumerate}[(1)]
	\item Replace all occurrences of "$\Rightarrow$" and "$\Leftrightarrow$" by their definition
	\item Replace each subformula of the form $\neg$$\neg G$ by $G$.
	\item Replace in $F$ every subformula of the form $\neg (G\vee H)$ by $\neg G\wedge \neg H$. If a subformula $\neg$$\neg K$ results, apply step (2).
	\item Replace in $F$ every subformula of the form $\neg (G\wedge H)$ by $\neg G\vee \neg H$. If a subformula $\neg$$\neg K$ results, apply step (2).
	\item Repeat (3) and (4) as often as possible.
	\item Replace in $F$ every subformula of the form $G\vee (H\wedge K)$ by $(G\vee H)\wedge (G\vee K)$
	\item Replace in $F$ every subformula of the form $(G\wedge H)\vee K$ by $(G\vee K)\wedge (H\vee K)$
	\item Repeat (6) and (7) as often as possible. Then return $F$ and stop.
\end{enumerate}
This is an algorithm, which returns a formula $\tilde{F}$ in CNF, such that $\tilde{F}\equiv F$.\\\\
\ul{Compactness Theorem}:\\
Let $\mathcal{F}$ be a countably infinite set of formulas. Then $\mathcal{F}$ is satisfiable iff every finite subset of $\mathcal{F}$ is satisfiable.\\\\
\ul{The Resolution Calculus}:\\
Assume, that $F$ is given in CNF. Write $F\equiv (L_{11}\vee\dots\vee L_{1n_1})\wedge\dots\wedge(L_{k1}\vee\dots\vee L_{kn_k})$ with literals $L_{ij}$.
\begin{enumerate}[(a)]
	\item The sets $\{L_{i1},L_{i2},\dots,L_{in_i}\}$ is called a \ul{clause} of $F$.
	\item The set $\mathcal{K}(F)=\{\{L_{11},\dots,L_{1n_1}\},\dots,\{L_{k1},\dots,L_{kn_k}\}\}$ is called the \ul{set of clauses} of $F$.
	\item Let $C_1,C_2$ be clauses. We say that a clause $C_3$ is a \ul{resolvent} of $C_1$ and $C_2$ if:
	\begin{enumerate}[(1)]
		\item There exists a literal $L\in C_1$ such that $\neg L\in C_2$ (Assume $\neg L\notin C_1,L\notin C_2$)
		\item $C_3=(C_1\backslash\{L\})\cup (C_2\backslash\{\neg L\})$
	\end{enumerate}
\end{enumerate}
$\lightning$ We may \ul{not} cancel two literals simultaneously!!!\\
\ul{Note}: If $C_3=\varnothing$ (i.e. if $C_1=\{L\}$ and $C_2=\{\neg L\}$), then $F$ is unsatisfiable.\\
A set of clauses $S$ is called unsatisfiable iff $\varnothing\in S$\\\\
\ul{The Resolution Lemma}\\
Let $\mathcal{K}(F)$ be the set of clauses of a formula $F$ in CNF. Let $C_1,C_2\in\mathcal{K}(F)$ and let $C_3$ be a resolvent of $C_1$ and $C_2$. Then $F$ is equivalent to every formula $\tilde{F}$ with $\mathcal{K}(\tilde{F})=\mathcal{K}(F)\cup\{C_3\}$.\\
Let $\mathcal{K}$ be a set of clauses.
\begin{enumerate}[(a)]
	\item We set $Res^0(\mathcal{K})=\mathcal{K}$\\
	$Res^1(\mathcal{K})=\mathcal{K}\cup\{C\ \vert\ C\text{ is a resolvent of two clauses in }\mathcal{K}\}$\\
	For $n\geq 2$ we let $Res^n(\mathcal{K})=Res^1(Res^{n-1}(\mathcal{K}))$
	\item We let $Res^\infty(\mathcal{K})=\bigcup_{n\geq 0}Res^n(\mathcal{K})$\\
	This is in fact a finite union since with finitely many atomic formulas $A_1,\dots,A_n$ in $\mathcal{K}$ we can format at most $4^n$ clauses.
\end{enumerate}
\ul{Resolution Theorem}:\\
A formula $F$ in CNF is unsatisfiable iff $\varnothing\in Res^\infty(\mathcal{K}(F))$.\\
Given a formula $F$, perform the following steps:
\begin{enumerate}[(1)]
	\item Bring $F$ into CNF and form $\mathcal{K}(F)$
	\item Calculate $Res^\infty (\mathcal{K}(F))$ by computing $Res^n(\mathcal{K}(F))$ until $Res^n(\mathcal{K}(F))=Res^{n+1}(\mathcal{K}(F))$. Then $F$ is unsatisfiable iff $\varnothing\in Res^\infty (\mathcal{K}(F))$.
\end{enumerate}
\section{Horn Logic}
Let $F$ be a propositional logic formula in CNF.\\
Write $F\equiv (L_{11}\vee\dots\vee L_{1m_1})\wedge\dots\wedge(L_{k1}\vee\dots\vee L_{km_k})$ with literals $L_{ij}$.
\begin{enumerate}[(a)]
	\item $F$ is called a \ul{Horn formula} if every disjunction $L_{i1}\vee\dots\vee L_{im}$ contains \ul{at most} one positive literal.
	\item A clause $\{L_{i1},\dots,L_{im_i}\}$ is called a \ul{Horn clause} if it contains at most one positive literal.
	\item The syntax of \ul{Horn logic} is the same as the syntax of propositional logic, except that we only allow Horn formulas.
\end{enumerate}
\begin{enumerate}[(a)]
	\item A Horn clause of the form $\{A_i\}$ is called a \ul{fact clause}.
	\item A Horn clause with a positive and at least one negative literal is called a \ul{procedural clause} or a \ul{rule}.
	\item A negative Horn clause (i.e. a Horn clause with no positive literal) is called a \ul{goal clause} or \ul{question clause}.
	\item A Horn clause containing a positive literal is called a \ul{program clause} or a \ul{definite clause}.
	\item A set of Horn clauses is called a \ul{logic program} or \ul{Horn clause program}.
\end{enumerate}
\ul{Marking algorithm}:\\
Suppose we are given a Horn formula $F$ (in CNF)
\begin{enumerate}[(1)]
	\item For every atomic formula $A$ which is in $\mathcal{K}(F)$ as a fact, we mark all appearances of $A$ and $\neg A$ in $F$.
	\item If $A_1,\dots,A_n$ have already been marked, then we check whether $F$ contains a clause of the following form: $\neg A_1\vee\neg A_2\vee\dots\vee\neg A_n\vee B$. In this case, we mark every occurrence of $B$ or $\neg B$ in $F$.
	\item Repeat (2) as often as possible.
	\item Check if $F$ contains a subformula $G$ of the form $\neg A_1\vee\dots\vee\neg A_l$ where all $A_1,\dots,A_l$ have been marked. In this case, we return "unsatisfiable" and stop the algorithm.
	\item Otherwise return "satisfiable".
\end{enumerate}
\ul{Then}:
\begin{enumerate}[(a)]
	\item This is an algorithm which decides whether $F$ is satisfiable or unsatisfiable
	\item If $F$ is satisfiable then we get a satisfying truth assignment by letting $\alpha(A_i)=\begin{cases}
	1, & \text{if }A_i\text{ has been marked}\\
	0, & \text{otherwise}
	\end{cases}$
	\item If $F$ contains $n$ atomic formulas, the algorithm stops after at most $n$ iterations of (2).
\end{enumerate}
The clause $\varnothing$ has a \ul{linear resolution} from a set of clauses $\mathcal{K}$ if there exists a clause $K_0\in\mathcal{K}(F)$ and a sequence of clauses $K_1,\dots,K_n$ with the following properties:
\begin{enumerate}[(a)]
	\item TODO GRAPH\\
	where the \ul{side clause} $B_{i-1}$ is either an element of $\mathcal{K}(F)$ or $B_{i-1}=K_0$ for some $j<i-1$
	\item $K_n=\varnothing$
\end{enumerate}
Then the sequence $K_0,K_1,\dots,K_n$ is called a \ul{linear resolution} of $F$.\\
Let $F$ be a formula in CNF. A linear resolution $K_0,K_1,\dots,K_n$ of $F$ is called an \ul{input resolution} if $B_i\in\mathcal{K}(F)$ for $i=0,1,\dots,n-1$\\
Let $F$ be a formula in CNF. An \ul{SLD-resolution} (linear resolution with unrestricted selection function for definite clauses) is an input resolution of the following form:
\begin{enumerate}[(a)]
	\item $K_0$ is a \ul{goal clause} (negative)
	\item For each resolution step, the parent clause $K_{i-1}$ is a non-negative Horn clause, i.e. program clause
\end{enumerate}
Hence an SLD-resolution has the following shape:\\
Let $\mathcal{K}(F)=\{\underbrace{P_1,\dots,P_n}_{\text{program clauses}},\underbrace{N_1,\dots,N_K}_{\text{negative clauses (goals)}}\}$\\
TODO GRAPH (LECTURE 4)\\
Notice: An SLD-resolution needs a \ul{selection function} for the $B_i$. The choice is a key component of logic programming.\\
\begin{enumerate}[(a)]
	\item Linear resolution is \ul{complete} for propositional logic formulas in CNF i.e. if $F$ is unsatisfiable, then there exists a linear resolution which proves it.
	\item SLD resolution is complete for Horn formulas
\end{enumerate}
\ul{PROLOG Notation}:\\
Let $F$ be a Horn formula in CNF.
\begin{enumerate}[(a)]
	\item $\{A\}$ is denoted by \texttt{A.} or \texttt{A:-.}
	\item $\{A,\neg B,\dots,\neg C\}$ is denoted by \texttt{A:-B,\dots,C.}
	\item $\{\neg A,\dots,\neg B\}$ is denoted by \texttt{?-A,\dots,B.}
\end{enumerate}
\ul{SLD-Tree}:\\
TODO GRAPH (LECTURE 5)\\
There are 2 main strategies to work through the SLD tree:
\begin{enumerate}[(a)]
	\item breadth-first-strategy
	\item depth-first-strategy or canonical strategy (needs back-tracking)
\end{enumerate}
\begin{enumerate}[(a)]
	\item The breadth-first-strategy is complete for Horn formulas.
	\item The depth-first-strategy is \ul{not} complete.
\end{enumerate}
\section{Predicate logic}
\ul{Syntax of Predicate logic}
\begin{enumerate}[(a)]
	\item A \ul{variable} is a symbol of the form $x_i$, where $i\geq0$ (or $x,y,z$)
	\item A \ul{function symbol} is of the form $f_i^{(k)}$ where $i,k\in\mathbb{N}$. Here $i$ is used to distinguish different functions and $k$ denotes the \ul{arity} (=number of arguments of $f_i$), also: $f,g,h,\dots$
	\item A \ul{term} is constructed by recursively applying the following rules:
	\begin{enumerate}[(c1)]
		\item a variable is a term
		\item If $t_1,\dots,t_k$ are terms and $f_i^{(k)}$ is a $k$-ary function symbol, then $f_i^{(k)}(t_1,\dots,t_k)$ is a term
	\end{enumerate}
	\item A function $f_i^{(0)}$ is called a \ul{constant}. Notation for constants: $a_i$ or $a,b,c$
	\item A \ul{predicate symbol} (or \ul{relation symbol}) is of the form $P_i^{(k)}$ where $i,k\in\mathbb{N}$ and $k$ is the \ul{arity} (classical relations are 2-ary $\hateq$ binary). We also write $P,Q,R$
	\item An atomic formula of predicate logic is of the form $P_i^{(k)}(t_1,\dots,t_k)$ where $t_1,\dots,t_k$ are terms and $P_i^{(k)}$ is a $k$-ary predicate symbol.
	\item A \ul{(predicate logic) formula} is recursively constructed using the following rules:
	\begin{enumerate}[(g1)]
		\item An atomic formula is a formula
		\item We have the connectives $\wedge,\vee,\neg$. So, $\neg F$, $F\wedge G$, \dots are defined for formulas $F,G$.
		\item Given a variable $x$ and a formula $F$, also $\forall x:F$ is a formula. $\forall$ is called the \ul{universal quantifier}.
		\item Given a variable $x$ and a formula $F$, also $\exists x:F$ is a formula. $\exists$ is called the \ul{existential quantifier}.
	\end{enumerate}
\end{enumerate}
\ul{Definitions}:
\begin{enumerate}[(a)]
	\item A \ul{subformula} of predicate logic formula $F$ is a formula contained in the iterative construction of $F$.
	\item A variable $x$ in a subformula $\forall x:G$ or $\exists x:G$ is called \ul{bound}.
	\item If $x$ is a variable which is not bound in a subformula, then $x$ is called a \ul{free} variable.
	\item If all variables in a formula $F$ are bound, then $F$ is called \ul{closed} (or a predicate logic proposition)
	\item If we delete all $\forall x_i,\exists x_i$ in a formula $F$, we get its \ul{matrix formula} $F^*$.
\end{enumerate}
\ul{Structures}:
\begin{enumerate}[(a)]
	\item A \ul{structure} $\alpha=(U,\phi,\psi,\xi)$ consists of the following parts:
	\begin{enumerate}[(\text{a}1)]
		\item $U$ is a set called the \ul{universe} (or the \ul{domain})
		\item $\phi$ is a map, which assigns to each function symbol $f_i^{(k)}$ a map: $\phi(f_i^{(k)}):U^k\rightarrow U$
		\item $\psi$ is a map, which assigns to each predicate $P_i^{(k)}$ a subset $\psi(P_i^{(k)})\subseteq U^k$
		\item $\xi$ is a map, which assigns to each variable $x_i$ an element $\xi(x_i)\in U$
	\end{enumerate}
	\item Let $\alpha=(U,\phi,\psi,\xi)$ be a structure. For every term $t$, we define a value $\alpha(t)\in U$ recursively as follows:
	\begin{enumerate}[(b1)]
		\item If $t=x_i$ is a variable, we let $\alpha(t)=\xi(x_i)$
		\item If $t=f_i^{(k)}(\tilde t_1,\dots,\tilde t_k)$, where $\alpha(\tilde t_1),\dots,\\alpha(\tilde t_k)\in U$ are already defined, we let $\alpha(t)=\phi(f_i^{(k)})(\alpha(t_1),\dots,\alpha(\hat t_k))\in U$
	\end{enumerate}
	\item Given a structure $\alpha=(U,\phi,\psi,\xi)$ and a formula $F$, we define a truth value $\alpha(F)\in\{0,1\}$ recursively as follows:
	\begin{enumerate}[(c1)]
		\item If $F=P_i^{(k)}(t_1,\dots,t_k)$ with terms $t_1,\dots,t_k$ we let $\alpha(P_i^{(k)}(t_1,\dots,t_k))=\begin{cases}
		1 & \text{if }(\alpha(t_1),\dots,\alpha(t_k))\in\psi(P_i^{(k)})\\
		0 & \text{otherwise}
		\end{cases}$
		\item The values $\alpha(\neg F)$, $\alpha(F\vee G)$, $\alpha(F\wedge G)$ are defined as in propositional logic
		\item If $F$ is of the form $\forall x:G$ then we define for every $u\in U$ a structure $\tilde\alpha_u=(U,\phi,\psi,\tilde\xi_u)$ where $\tilde\xi_u(x)=u$ and $\tilde\xi_u(y)=\xi(y)$ for all other variables. Then we define $\alpha(\forall x, G)=\begin{cases}
		1 & \text{if } \tilde\alpha_u(G)=1 \text{ for all } u\in U\\
		0 & \text{otherwise}
		\end{cases}$
		\item If $F$ is of the form $F=\exists x : G$ then we define the structures $\tilde\alpha_u$ for $u\in U$ as in (c3) and let $\alpha(\exists x:G)=\begin{cases}
		1 & \text{if } \tilde\alpha_u(G)=1 \text{ for some } u\in U\\
		0 & \text{otherwise}
		\end{cases}$
	\end{enumerate}
\end{enumerate}
Let $F$, $G$ be formulas.
\begin{enumerate}[(a)]
	\item A structure $\alpha=(U,\phi,\psi,\xi)$ is called \ul{suitable} for $F$ if all variables, function symbols and predicates appearing in $F$ are assigned values in $\alpha$
	\item $\alpha$ is called a \ul{model} for $F$ if $\alpha(F)=1$. We write $\alpha\models F$
	\item $F$ is called a \ul{tautology} or \ul{valid} if $\alpha\models F$ for every suitable $\alpha$
	\item $F$ is called \ul{unsatisfiable} if $\alpha(F)=0$ for every suitable $\alpha$
\end{enumerate}
The logical system we just defined is called \ul{first order predicate logic}.\\
Propositional logic can be embedded into predicate logic:
\begin{itemize}
	\item we allow no variables, no functions and only 0-ary predicates $P_i^{(0)}$; moreover we don't allow quantifiers
	\item we interpret $P_i^{(0)}=A_i$ as propositions and let $\alpha(A_i)\hateq\psi(P_i^{(0)})=\begin{cases}
	\{\}\\
	\{\varnothing\}
	\end{cases}$ via $\alpha(A_i)=\begin{cases}
	0 & \text{if }\psi(P_i^{(0)})=\{\}\\
	1 & \text{if }\psi(P_i^{(0)})=\{\varnothing\}
	\end{cases}$ for some structure $\alpha=(U,\phi,\psi,\xi)$ where $U=\{0,1\}$
\end{itemize}
\ul{Definitions}:
\begin{enumerate}[(a)]
	\item Two formulas $F$, $G$ are called \ul{equivalent} if $\alpha(F)=\alpha(G)$ for every structure $\alpha=(U,\phi,\psi,\xi)$ which is suitable for both $F$ and $G$
	\item  A formula $F$ is said to be in \ul{prenex form} if $F=Q_1x_{i_1}:Q_2x_{i_2}:\dots:Q_kx_{i_k}:G$ such that $Q_1,\dots,Q_k$ are quantifiers and $x_{i_j}$ variables and $G$ is quantifier-free
\end{enumerate}
\ul{Fundamental equivalences}:
\begin{enumerate}[(a)]
	\item All fundamental equivalences of propositional logic still hold
	\item $\neg(\forall x:F)\equiv (\exists x:\neg F)$\\
	$\neg(\exists x:F)\equiv (\forall x:\neg F)$
	\item $(\forall x : F)\wedge (\forall x : G)\equiv \forall x : (F\wedge G)$\\
	$(\exists x : F)\vee (\exists x : G)\equiv \exists x : (F\vee G)$
	\item $\forall x:\forall y: F\equiv\forall y:\forall x:F$\\
	$\exists x:\exists y: F\equiv\exists y:\exists x:F$
	\item If $H$ does not contain $x$, then\\
	$(\forall x: F)\wedge H\equiv \forall x:(F\wedge H)$\\
	$(\forall x: F)\vee H\equiv \forall x:(F\vee H)$\\
	$(\exists x: F)\wedge H\equiv \exists x:(F\wedge H)$\\
	$(\exists x: F)\vee H\equiv \exists x:(F\vee H)$\\
\end{enumerate}
Let $F$ be a formula, let $x$ be a variable which appears in $F$, and let $t$ be a term.
\begin{enumerate}[(a)]
	\item If $x$ appears freely in $F$, we replace every occurrence of $x$ by $t$ we get a new formula $F\vert_{x\mapsto t}$ which is called the \ul{substitution} of $x$ by $t$
	\item We can also substitute bound variables $x$, but only by other variables. $\forall x:F\rightarrow \forall y:F\vert_{x\mapsto y}$. This is called a \ul{bound substitution} or \ul{bound variable renaming}
\end{enumerate}
\ul{Cleaned form of a Predicate Logic Formula}: Given a formula $F$, the following step brings it to \ul{cleaned form:} Use bound substitutions to make the names of bound variables pairwise distinct with free variables. The result is called the \ul{cleaned form} of $F$.\\
Using bound renamings $\forall x : F\equiv \forall y : F\vert_{x\mapsto y}$, we can make all bound variables pairwise distinct and distinct with the free variable names.\\
\ul{Transformation to Prenex Form}: The following instructions define an algorithm which transforms a given formula $F$ to an equivalent formula $G$ such that $G$ is in cleaned Prenex form.
\begin{enumerate}[(1)]
	\item Replace $F$ by an equivalent formula in cleaned form
	\item If $F$ is an atomic formula then return $F$ and stop
	\item If $F$ is of the form $F=\neg \tilde F$, then apply the algorithm to $\tilde F$ and get $\tilde Q_1x_{i_1}:\dots:\tilde Q_kx_{i_k}:H$ with quantifiers $\tilde Q_1,\dots,\tilde Q_k$ and a quantifier-free formula $H$. Then return $\hat Q_1x_{i_1}:\dots:\hat Q_{i_k}:\neg H$ where $\hat Q_i=\exists$ if $\tilde Q_i=\forall$ and $\hat Q_i=\forall$ if $\tilde Q_i=\exists$
	\item If $F$ is of the form $F=G\vee H$ then apply the algorithm to $G$ and $H$ and get $G\equiv \tilde Q_1x_{i_1}:\dots:\tilde Q_kx_{i_k}:\tilde G$ and $H\equiv \hat Q_1y_1\dots \hat Q_ly_l:\tilde H$ where $\tilde Q_i,\hat Q_j$ are quantifiers and $\tilde G, \tilde H$ are quantifier-free. Then return $\tilde Q_1x_{i_1}:\dots:\tilde Q_kx_{i_k}:\hat Q_1y_1:\dots\hat Q_ly_l:(\tilde G\vee \tilde H)$
	\item If $F=G\wedge H$ then apply the algorithm as in step (4) and return $\tilde Q_1x_{i_1}:\dots:\tilde Q_kx_{i_k}:\hat Q_1y_1:\dots\hat Q_ly_l:(\tilde G\wedge \tilde H)$
	\item If $F=\forall x:G$ resp. $F=\exists x:G$ then apply the algorithm to $G$ and get $G\equiv\tilde Q_1x_{i_1}:\dots:\tilde Q_kx_{i_k}:\tilde G$ where $\tilde Q_1,\dots,\tilde Q_k$ are quantifiers and $\tilde G$ is quantifier-free. Then return $\forall x:\tilde Q_1x_{i_1}:\dots:\tilde Q_kx_{i_k}:\tilde G$ (resp. $\exists x:\tilde Q_1x_{i_1}:\dots:\tilde Q_kx_{i_k}:\tilde G$) and stop.
\end{enumerate}
Two formulas $F,G$ are called \ul{satisfiability equivalent} if ($F$ is satisfiable iff $G$ is satisfiable)\\
\ul{The Skolem Form of a Prenex Formula}: Let $F$ be a formula in prenex form: $F=Q_1x_1:\dots:Q_kx_k:G$ where $Q_i$ are quantifiers and $G$ is quantifier free. The following algorithm produces a formula $G$ in prenex form such that $G$ is satisfiability equivalent to $F$ and $G$ contains only universal quantifiers:
\begin{enumerate}[(1)]
	\item If there exists an existential quantifier in $F$ then we write $\forall x_1:\forall x_2:\dots:\forall x_l:\exists x_{l+1}:H$ where $l\geq 0$ and $H$ is in prenex form. Let $f_i^{(k)}$ be a $k$-ary function symbol not used in $F$. Then replace $F$ by the formula $\forall x_1:\dots:x_l:H$, $x_{l+1}\mapsto f_i^{(l)}(x_1,\dots,x_l)$
	\item Repeat Step (1) as often as possible
	\item Return the resulting formula $G$. It is said to be in Skolem form or a \ul{Skolemization} of $F$.
\end{enumerate}
\ul{Löwenhain-Skolem}: Every cleaned prenex formula is satisfiability equivalent to one having only universal quantifiers. More precisely, for $F=\forall x_1:\dots:\forall x_l:\exists x_{l+1}:H$, where $H$ is in cleaned prenex form, we let $f_1^{(l)}$ be a new function symbol. Then $F$ is satisfiability equivalent to  $G=\forall x_1:\dots:\forall x_l:H\vert_{x_{l+1}\mapsto f_i^{(l)}(x_1,\dots,x_l)}$\\
\ul{Matrix Clause Form}: Let $F$ be a predicate logic formula. Apply the following instructions:
\begin{enumerate}[(1)]
	\item Transform $F$ into an equivalent formula $G$ in cleaned prenex form
	\item Let $y_1,\dots,y_m$ be the free variables in $G$. Replace $G$ by $\tilde G=\exists y_1:\exists y_2:\dots:\exists y_m:G$
	\item Compute the Skolem form of $\tilde G$ and get $H=\forall x_1:\dots:\forall x_l:H^*$, $H^*$ matrix formula of $H$ (quantifier-free, no free variables)
	\item Calculate the CNF of $H^*$ where we consider atomic formulas like "propositions". Call the result $\tilde F$.
	\item Return the set $\mathcal{K}(\tilde F)$
\end{enumerate}
Then $F$ is satisfiability equivalent to $\tilde F$ and $\mathcal{K}(\tilde F)$ is satisfiable \ul{iff} $F$ is satisfiable.\\
\ul{Church's Theorem}: There is no algorithm which decides in finitely many steps whether a given predicate logic formula is satisfiable or not.\\
\ul{Goals}:
\begin{enumerate}[(1)]
	\item Find the "smallest" universe in which $F$ could have a model
	\item If $F$ is unsatisfiable, can we prove it in finitely many steps?
\end{enumerate}
Assume, that $F$ is in matrix-clause form.
Let $D(F)$ be the set of all variable-free terms in the function symbols appearing in $F$. If $F$ contains no constant, then introduce the constant $a$. This set $D(F)$ can be constructed recursively as follows:
\begin{enumerate}[(1)]
	\item All constants are in $D(F)$.
	\item If $f_i^{(k)}$ is a $k$-ary function symbol and $t_1,\dots,t_k\in D(F)$, then $f_i^{(k)}(t_1,\dots,t_k)\in D(F)$.\\
	The set $D(F)$ is called the \ul{Herbrand universe} of $F$
\end{enumerate}
A structure $\alpha=(U,\phi,\psi,\xi)$ is called a \ul{Herbrand structure} if:
\begin{enumerate}[(1)]
	\item $U=D(F)$
	\item If $f_i^{(k)}$ is a $k$-ary function symbol in $F$ and $t_1,\dots,t_k\in D(F)$, then $\phi(f_i^{(k)}):\underset{(t_1,\dots,t_k)\mapsto f_i^{(k)}(t_1,\dots,t_k)}{U^k\rightarrow U=D(F)}$\\
	Hence $\alpha(f_i^{(k)}(t_1,\dots,t_k))=f_i^{(k)}(t_1,\dots,t_k)\in U$
\end{enumerate}
A Herbrand structure $\alpha=(U,\phi,\psi,\xi)$ for $F$ s.t. $\alpha\models F$ is called a \ul{Herbrand model} for $F$.\\
\ul{Löwenhain-Skolem}: Let $F$ be in matrix clause form. Then $F$ is satisfiable iff $F$ has a Herbrand model. In particular, if $F$ has a model, then it has a model with a countable universe.\\
Let $F$ be in matrix clause form: $F=\forall x_1:\dots:\forall x_n:F^*$. The \ul{Herbrand expansion} of $F$ is the following countably infinite set of formulas: $E(F)=\{F^*\vert_{x_1\mapsto t_1,\dots,x_n\mapsto t_n}:t_1,\dots,t_n\in D(F)\}$\\
\ul{Herbrand-Skolem-Gödel}: A closed formula $F$ in Skolem form is satisfiable, iff $E(F)$ is satisfiable (in the sense of propositional logic).\\
\ul{Basic Resolution Algorithm}: Given a predicate logic formula $F$, perform the following steps:
\begin{enumerate}[(1)]
	\item Transform $F$ (using satisfiability equivalence) to the form $F=\forall x_1:\dots:\forall x_n:G$ (as above)
	\item Let $M=\varnothing$ and $i=0$
	\item Increase $i$ by 1. Compute the next element $H_i$ of $E(F)$.\\
	Let $M=\{H_1,\dots,H_i\}$.
	\item Consider $M$ as a set of propositional logic formulas. Check if $M$ is unsatisfiable. If "True", then return "$F$ is unsatisfiable" and stop. Otherwise continue with (3).
\end{enumerate}
This is a procedure. If $F$ is unsatisfiable, it stops after finitely many steps and returns "$F$ is unsatisfiable". If $F$ is satisfiable, it produces an infinite loop.\\
TODO VL\\
\section{Equational Logic}
\ul{Syntax of Equational Logic}:
\begin{enumerate}[(a)]
	\item A \ul{variable} is a symbol of the form $x_i$ ($i\in\mathbb{N}$) or $x,y,z,\dots$
	\item A \ul{function symbol} is of the form $f_i^{(k)}$ where $k$ is the arity (number of arguments) of $f_i$ (or $f,g,h\dots$)
	\item A \ul{term} is a variable or of the form $f_i^{(k)}(t_1,\dots,t_k)$ where $t_1,\dots,t_k$ are previously constructed terms
	\item An \ul{equational logic formula} is of the form $s=t$ where $s,t$ are terms
\end{enumerate}
\ul{Semantics of Equational Logic}:\\
Let $F:s=t$ be an equation.
\begin{enumerate}[(a)]
	\item A \ul{structure} $\alpha=(U,\phi,\xi)$ which is \ul{suitable} for $F$ consists of:
	\begin{enumerate}[(1)]
		\item a non-empty set $U$
		\item a map $\phi$ s.t. $\phi(f_i^{(k)}):U^k\rightarrow U$
		\item a map $\xi$ s.t. $\xi(x_i)\in U$
	\end{enumerate}
	\item The value $\alpha(t)$ of a term is defined as in predicate logic: $\alpha(t)\in U$
	\item A pair $\iota=(U,\phi)$ is called an \ul{interpretation} of $F$ if:
	\begin{enumerate}[(1)]
		\item $U$ is a non-empty set
		\item $\phi(f_i^{(k)}):U^k\rightarrow U$ for every $k$-ary $f_i^{(k)}$
	\end{enumerate}
	Every structure $\alpha=(U,\phi,\xi)$ is then called compatible with $\iota$
	\item Given an interpretation $\iota=(U,\phi)$, the truth value $\iota(F)$ is defined by $\iota(F)=\begin{cases}
	1 & \text{if }\alpha(s)=\alpha(t)\text{ for all compatible structures }\alpha\\
	0 & \text{ otherwise}
	\end{cases}$
\end{enumerate}
\ul{Definition}:
\begin{enumerate}[(a)]
	\item An interpretation $\iota=(U,\phi)$ is called a \ul{model} for $F$ if $\iota(F)=1$
	\item Given a set of formulas $M=\{F_1,\dots,F_r\}$, an interpretation $\iota=(U,\phi)$ which is suitable for all $F_i$ and satisfies $\iota(F_1)=\dots=\iota(F_r)=1$ is called a \ul{model} fpr $M$.
	\item A formula $F:s=t$ is \ul{valid} or a tautology if $\iota(F)=1$ for all suitable interpretations $\iota$.
	\item $F$ is \ul{unsatisfiable} if there is no model
\end{enumerate}
Let $M$ be a set of equations, and let $F:s=t$ be a further equation.
\begin{enumerate}[(a)]
	\item Two equations $F:s=t$ and $G:\tilde s=\tilde t$ are called \ul{(semantically) equivalent} if $\iota(F)=\iota(G)$ for all suitable interpretations $\iota$. We write: $F\equiv G$
	\item The equation $F$ is said to \ul{follow semantically} from the set of equations $M$ if $\iota(F)=1$ for every interpretation $\iota$ which is a model for $M$. In this case we write $M\models F$.
\end{enumerate}
\ul{Term Rewriting}:
\begin{enumerate}[(a)]
	\item Define \ul{substitutions} as in predicate logic, if $x$ is a variable which appears in a formula $F$ and $t$ is a term which does not contain $x$, we can replace every occurrence of $x$ in $F$ by $t$ and we get a formula $F\vert_{x\mapsto t}$. Then $\sigma=(x\mapsto t)$ is a substitution.
	\item A set of substitutions is written as $\sigma=(x_1\mapsto t_1,\dots,x_n\mapsto t_n)$
	\item We can say that a term $t$ is obtained from a term $s$ using a formula $F:\tilde s=\tilde t$ in one \ul{term rewriting step} if there exists a substitution $\sigma$ such that
	\begin{enumerate}[(1)]
		\item $\sigma(\tilde s)$ is a subterm of $s$
		\item $t$ is obtained from $s$ by replacing $\sigma(\tilde s)$ in one position by $\sigma(\tilde t)$
	\end{enumerate}
	In this case we write $s\overset{F}{\rightarrow} t$
	\item The reflexive, transitive hull of the relations $\overset{F}{\rightarrow}$ where $F\in M$, $M$ set of equations, is called the \ul{term rewriting system (TRS)} defined by $M$. Notation: $\overset{M}{\rightarrow}$\\
	In other words, we let $s\overset{F}{\rightarrow} t$ iff there exist terms $t_0,\dots,t_r$ such that $s=t_0\overset{F_1}{\rightarrow}t_1\overset{F_2}{\rightarrow}t_2\overset{F_3}{\rightarrow}\dots\overset{F_r}{\rightarrow}t_r=t$ with $F_i\in M$. (Here $r=0$ means $s\overset{M}{\rightarrow}s$)
	\item The reflexive, transitive, symmetric closure of the relations $\overset{F}{\rightarrow}$ with $F\in M$ is called the \ul{equivalence relation} generated by the relations $\overset{F}{\rightarrow}$ and is denoted by $s\overset{M}{\leftrightarrow} t$.\\
	Explicitly, we have $s\overset{M}{\leftrightarrow} t$ iff there exist terms $t_0,\dots,t_r$ and formulas $F_0,\dots,F_r$ in $M$ s.t. $s=t_0\overset{F_1}{\rightarrow}t_1\overset{F_2}{\leftarrow}t_2\overset{F_3}{\rightarrow}\dots\overset{F_r}{\rightarrow}t_r=t$
\end{enumerate}
\ul{Substitution Theorem}: Let $M$ be a set of formulas, let $s,t$ be terms and let $\sigma$ be a substitution.
\begin{enumerate}[(a)]
	\item If $s\overset{M}{\rightarrow}t$ then $\sigma(s)\overset{M}{\rightarrow}\sigma(t)$
	\item If $s\overset{M}{\leftrightarrow}t$ then $\sigma(s)\overset{M}{\leftrightarrow}\sigma(t)$
\end{enumerate}
Let $M$ be a set of equations, and let $T$ be the set of all terms which one can form using the variables and the function symbols which appear in $M$.\\
Then $s\overset{M}{\leftrightarrow}t$ is an equivalence relation on $T$. The equivalence class of a term $t\in T$ is denoted by $\left[t\right]=\{s\in T\ \vert\ s\overset{M}{\leftrightarrow}t\}$. The set of all these equivalence classes is denoted by $T/M$ and is called the \ul{free model} (or the \ul{free algebra}) of $M$.\\
Let $M$ be a set of equations and $F:s=t$ an equation in $M$.\\
Let $\iota=(T/M,\phi)$ be an interpretation. Then $\iota(F)=1$.\\
\ul{Theorem of Birkhoff}: Let $M$ be a set of equations, and let $F:s=t$ be an equation. Let $T$ be defined as above. Then the following conditions are equivalent:
\begin{enumerate}[(a)]
	\item $s\overset{M}{\rightarrow}t$
	\item $M\models F$
	\item For every interpretation $\iota=(T/M,\phi)$ which is suitable for $M,F$, we have $\iota(F)=1$
\end{enumerate}
\ul{Properties of TRS}: Let $M$ be a set of equations and $\overset{M}{\rightarrow}$ the TRS defined by $M$.
\begin{enumerate}[(a)]
	\item The TRS is called \ul{noetherian} (or \ul{terminating}) if every chain of rewriting steps $t_1\overset{F_1}{\rightarrow}t_2\overset{F_2}{\rightarrow}t_3\overset{F_3}{\rightarrow}\dots$ with $F_i\in M$ is \ul{eventually stationary}, i.e. there exists $N>0$ s.t. $t_N=t_{N+1}=\dots$
	\item The TRS $\overset{M}{\rightarrow}$ has the \ul{Church-Rosser property} if for all terms $t_1,t_2$ such that $t_1\overset{M}{\rightarrow}t_2$, there exists a term $t_3$ such that $t_1\overset{M}{\rightarrow}t_3$ and $t_2\overset{M}{\rightarrow}t_3$
	\item The TRS $\overset{M}{\rightarrow}$ is called \ul{confluent} if for all terms $t_0,t_1,t_2$ such that $t_0\overset{M}{\rightarrow}t_1$ and $t_0\overset{M}{\rightarrow}t_2$ there exists a term $t_3$ such that $t_1\overset{M}{\rightarrow}t_3$ and $t_2\overset{M}{\rightarrow}t_3$
	\item A term $t$ is called \ul{irreducible} w.r.t. $\overset{M}{\rightarrow}$ if there exists no term $t'\neq t$ with $t\overset{M}{\rightarrow}t'$
	\item A term $t'$ is called \ul{a normal form} of a term $t$ w.r.t. $\overset{M}{\rightarrow}$ if $t\overset{M}{\rightarrow}t'$ and $t'$ is irreducible.\\
	Notation: $t'=NF(t)$
\end{enumerate}
Let $M$ be a set of equations and $\overset{M}{\rightarrow}$ the TRS defined by $M$.
\begin{enumerate}[(a)]
	\item Then $\overset{M}{\rightarrow}$ has the Church-Rosser property iff $\overset{M}{\rightarrow}$ is confluent
	\item If $\overset{M}{\rightarrow}$ is noetherian and confluent, then every term $t$ has a unique normal form $NF(t)$.
\end{enumerate}
Let $\overset{M}{\rightarrow}$ be noetherian and confluent.
\begin{enumerate}[(a)]
	\item For two terms $s,t$ we have $s\overset{M}{\rightarrow}t$ iff $NF(s)=NF(t)$
	\item To check whether $s\overset{M}{\leftrightarrow}t$ it suffices to apply term rewriting steps to $s$ and to $t$ as long as possible and to compare the results.
\end{enumerate}
A TRS $\overset{M}{\rightarrow}$ is called \ul{convergent} or \ul{complete} if $\overset{M}{\rightarrow}$ is noetherian and confluent.\\
Let $\overset{M}{\rightarrow}$ be the TRS generated by a set of equations $M$. Let $F_1:s_1=t_1$ and $F_2:s_2=t_2$ be two equations in $M$. If there exists a subterm $\tilde s$ of $s_1$ such that the most general unifier $\sigma$ of $\tilde s$ and $s_2$ exists, then $(\sigma(t_1);\sigma(s_1)\vert_{\sigma(\tilde s)\mapsto \sigma(t_2)})$ is called a \ul{critical pair} of $M$.\\
\ul{Knuth-Bendix Criterion}: Suppose that $\overset{M}{\rightarrow}$ is noetherian. Then $\overset{M}{\rightarrow}$ is confluent if for every critical pair $(c_1;c_2)$ there exists a term $t$ s.t. $c_1\overset{M}{\rightarrow}t$ and $c_2\overset{M}{\rightarrow}t$.\\
\ul{Knuth-Bendix Completion Procedure}: Suppose there exists a term ordering $>$ s.t. every equation $F:s=t$ in $M$ satisfies $s>_\tau t$. Then we can construct a set of equations $\tilde M\geq M$ s.t. $\overset{M}{\rightarrow}$ is convergent using the following procedure:
\begin{enumerate}[(1)]
	\item Form all critical pairs $(c_1;c_2)$ and if $c_1>_\tau c_2$ then append $c_1=c_2$ to $M$. If $c_2>_\tau c_1$ then append $c_2=c_1$ to $M$.
	\item If neither $c_1>_\tau c_2$ nor $c_2>_\tau c_1$ then return "FAIL".
\end{enumerate}
TODO VL erste Hälfte nachholen\\
\ul{Knuth-Bendix Criterion, Superimposition Criterion}: Let $\overset{M}{\rightarrow}$ be a set of equations such that the TRS $\overset{M}{\rightarrow}$ is noetherian. Then $\overset{M}{\rightarrow}$ is confluent iff, for every critical pair $(c_1;c_2)$ there exists a term $t$ such that $c_1\overset{M}{\rightarrow}t$ and $c_2\overset{M}{\rightarrow}t$.\\
In particular, we can check in finitely many steps whether $\overset{M}{\rightarrow}$ is confluent as follows:
\begin{enumerate}[(1)]
	\item Compute all critical pairs $(c_1;c_2)$
	\item For each critical pair $(c_1;c_2)$ reduce $c_1\overset{M}{\rightarrow}t_1$ and $c_2\overset{M}{\rightarrow}t_2$ with $t_1,t_2$ irreducible. Check if $t_1=t_2$.
\end{enumerate}
Let $M$ be a set of equations, and let $T$ be the set of all terms which can be constructed using the variables and the function symbols in $M$.\\
An ordering relation $>_\tau$ on $T$ is called a \ul{term ordering} if:
\begin{enumerate}
	\item $>_\tau$ is transitive (i.e. $t_1>_\tau t_2$ and $t_2>_\tau t_3$ implies $t_1>_\tau t_3$)
	\item If $t_1\dots t_k$ are terms in $T$ and for some $i$ we have $t_i>_\tau t_i'$ for some $t_i'\in T$ then $f(t_1,\dots,t_k)>_\tau f(t_1,\dots,t_{i-1},t_i',t_{i+1},\dots,t_k)$
	\item If $\sigma$ is a substitution and $t>_\tau t'$ then $\sigma(t)>_\tau\sigma(t')$
	\item $>_\tau$ is noetherian, i.e. there is no infinite chain $t_1>_\tau t_2>_\tau t_3>_\tau \dots$
\end{enumerate}
Let $M$ be a set of equations. If $>_\tau$ is a term ordering s.t. $s>_\tau t$ for every equation $F:s=t$ in $M$. Then the TRS $\overset{M}{\rightarrow}$ is noetherian.\\
\ul{Knuth-Bendix Procedure}: Let $M$ be a set of equations s.t. $\overset{M}{\rightarrow}$ is noetherian. Assume that $>_\tau$ is a term ordering s.t. $s>_\tau t$ for every equation $F:s=t$ in $M$.\\
Then the following procedure enumerates a set of equations $\tilde M\supseteq M$ s.t. $\overset{\tilde M}{\rightarrow}$ is convergent:
\begin{enumerate}[(1)]
	\item Form the set of al critical pairs $(c_1;c_2)$ of $M$.
	\item For every critical pair $(c_1;c_2)$ reduce $c_1\overset{M}{\rightarrow} c_1'$ and $c_2\overset{M}{\rightarrow} c_2'$ with $c_1',c_2'$ irreducible.\\
	If you always get $c_1'=c_2'$, return $M$ and stop.
	\item Let $(c_1;c_2)$ be a critical pair s.t. $c_1'\neq c_2'$. Check if $c_1'>_\tau c_2'$. If this is the case, append $F':c_1'=c_2'$ to $M$ and continue with (1).
	\item Check if $c_2'>_\tau c_1'$. If this is the case, append $F':c_2'=c_1'$ to $M$ and continue with (1).
	\item If neither $c_1'>_\tau c_2'$ nor $c_2'>_\tau c_1'$ holds, then return "FAIL" and stop.
\end{enumerate}
\ul{Syntax of Modal Logic}:
\begin{enumerate}[(a)]
	\item Every propositional logic formula is a modal logic formula.
	\item Given modal logic formulas $F,G$, also $\not F,\ F\wedge G$ and $F\vee G$ are modal logic formulas.
	\item Given a modal logic formula $F$, also $\square F$ and $\diamond F$ are modal logic formulas.\\
	\ul{Ideal}: $\square F=F$ holds necessarily, $\diamond F=F$ holds possibly/eventually
\end{enumerate}
\ul{Semantics of Modal Logic}:
\begin{enumerate}[(a)]
	\item A modal logic \ul{structure} (or \ul{Kripke structure}) $\alpha$ is a triple $\alpha=(W,R,\xi)$ consisting of the following parts:
	\begin{enumerate}[(1)]
		\item $W$ is a non-empty set. It is called the set of possible \ul{words} or the set of \ul{reference points}.
		\item $R\subseteq W\times W$ is a relation on $W$ called the \ul{reachability} or \ul{accessibility relation}. A reference point $t\in W$ is called \ul{reachable} from $s\in W$ if $(s,t)\in R$.
		\item Let $M$ be a set of atomic formulas, i.e., propositions. Then $\xi:M\times W\rightarrow\{0,1\},\ (A,s)\mapsto\xi(A,s)$.
	\end{enumerate}
	\item Let $\alpha=(W,R,\xi)$ be a structure which is suitable for a formula $F$, i.e. all propositions in $F$ are contained in $M$, and let $s\in W$. Then we define $\alpha(F,s)$ recursively as follows:
	\begin{enumerate}[(1)]
		\item If $F=A$ is an atomic formula, we let $\alpha(F,s)=\xi(A,s)$
		\item If $F=\neg G$, then $\alpha(F,s)=1-\alpha(G,s)$
		\item If $F=G\vee H$, then $\alpha(F,s)=\begin{cases}
		1&\text{if }\alpha(G,s)=1\text{ or }\alpha(H,s)=1\\
		0&\text{otherwise}
		\end{cases}$
		\item If $F=G\wedge H$, then $\alpha(F,s)=\begin{cases}
		1&\text{if }\alpha(G,s)=1=\alpha(H,s)\text{ or }\alpha(H,s)=1\\
		0&\text{otherwise}
		\end{cases}$
		\item If $F=\square G$, then $\alpha(F,s)=\begin{cases}
		1&\text{if }\alpha(G,t)=1\text{ for all }t\in W\text{ such that }(s,t)\in R\\
		0&\text{otherwise}
		\end{cases}$
		\item If $F=\diamond G$, then $\alpha(F,s)=\begin{cases}
		1&\text{if }\alpha(G,t)=1\text{ for some }t\in W\text{ such that }(s,t)\in R\\
		0&\text{otherwise}
		\end{cases}$
	\end{enumerate}
\end{enumerate}
\ul{Definitions}:
\begin{enumerate}[(a)]
	\item If $F$ is a formula and $\alpha=(W,R,\xi)$ a structure such that $\alpha(F,s)=1$, we write $s\vert\models_\alpha F$ and we say "$s$ forces $F$" in the structure $\alpha$. If $\alpha$ is clear, we also write $s\vert\models F$.
	\item We say that $\alpha=(W,R,\xi)$ is a \ul{model} for $F$ (or $F$ is \ul{valid}/\ul{holds}) in the structure $\alpha$ if $\alpha(F,s)=1$ for all $s\in W$. In this case we write $\alpha\models F$ TODO MODELS UND FORCE SYMBOLE
	\item Let $W$ be a set and $R\subseteq W\times W$ a relation. Then the pair $(W,R)$ is called a \ul{frame}. We write $\mathcal{R}=(W,R)$.
	\item If $F$ holds in all structures $\alpha=(W,R,\xi)$ based on a fixed frame $\mathcal{R}=(W,R)$, we say that $F$ \ul{holds} in $\mathcal{R}$ or $F$ is \ul{valid} in $\mathcal{R}$.
\end{enumerate}
The \ul{modal rank} $MR(F)$ of a formula $F$ is defined as follows:
\begin{enumerate}[(a)]
	\item If $F$ is a proposition then $MR(F)=0$.
	\item If $F=\neg G$ then $MR(F)=MR(G)$.
	\item If $F=G\vee H$ or $F=G\wedge H$ then $MR(F)=\max\{MR(G),MR(H)\}$
	\item If $F=\square G$ or $F=\diamond G$ then $MR(F)=MR(G)+1$
\end{enumerate}
For $R\subseteq W\times W$ and $n\geq 2$ we define the \ul{$n-th$ iteration} $R^{(n)}\subseteq W\times W$ as follows:\\
$(s,t)\in R^{(n)}$ iff $s=t_0\sim_R t_1\sim_R t_2\sim_R\dots\sim_R t_n=t$ for some $t_1,\dots,t_{n-1}\in W$.\\
\ul{Coincidence Lemma}: For a modal logic formula $F$ and two structures $\alpha=(W,R,\xi)$ and $\beta=(W,R,\tilde\xi)$ based on the same frame $\mathcal{R}=(W,R)$ we have $\alpha(F,s)=\beta(F,s)$ for some $s\in W$ iff $\alpha(A,t)=\beta(A,t)$ for all propositions which appear in $F$ for all $t\in W$ such that $(s,t)\in R^{(n)}$ with $n\leq MR(F)$. In other words, $\alpha(F,s)$ is determined by all $\alpha(A,t)$ with $(s,t)\in R^{(n)}$, $n\leq MR(F)$.\\
\begin{enumerate}[(a)]
	\item A formula $F$ is called \ul{valid} or a \ul{tautology} if it is valid in every frame $\mathcal{R}=(W,R)$.\\
	Equivalently, $\alpha(F,s)=1$ for every structure $\alpha$ which is suitable for $F$ and every $s\in W$.
	\item Let $M$ be a set of formulas. We say that a formula $F$ is a \ul{(semantic) consequence} of $M$ if $F$ is valid in every structure $\alpha$ s.t. all formulas of $M$ are valid in $\alpha$
	\item We say that two formulas $F$ and $G$ are \ul{(semantically) equivalent} iff ($\alpha(F,s)=1$ holds iff $\alpha(G,s)=1$ for all structures $\alpha$ suitable for both $F$ and $G$ and for all $s\in W$).\\
	Notation: $F\equiv G$
	\item Let $M$ be a set of formulas. We say that $F$ is a \ul{frame consequence} of $M$ iff ($R\vDash G$ for all $G\in M$ then $\mathcal{R}\vDash F$ for every suitable frame $\mathcal{R}$)
	\item We say that two formulas $F$ and $G$ are \ul{frame equivalent} if ($\mathcal{R}\vDash F$ iff $\mathcal{R}\vDash G$ for every suitable $\mathcal{R}$)
\end{enumerate}
If $F,G$ are equivalent then $F,G$ are frame equivalent. The converse is not true in general.\\
\ul{Fundamental Equivalences of Modal Logic}: Let $F,G$ be two formulas. Then we have all fundamental equivalences of propositional logic plus the following:
\begin{enumerate}[(a)]
	\item $\neg\square F\equiv \diamond\neg F$
	\item $\neg\diamond F\equiv \square\neg F$
	\item $\square(F\Rightarrow G)$ implies $\square F\Rightarrow\square G$ (semantic consequence)
	\item $\diamond(F\Rightarrow G)\equiv \square F\Rightarrow\diamond G$
	\item $\square(F\Rightarrow G)$ implies $\diamond F\Rightarrow\diamond G$
	\item $\square (F\wedge G)\equiv \square F\wedge \square G$
	\item $\diamond (F\vee G)\equiv \diamond F\vee \diamond G$
	\item If $F$ is a tautology then $\square F$ is a tautology (necessitation).
\end{enumerate}
A formula $F$ is said to be in \ul{quasi-disjunctive normal form} (QDNF) iff $F=(L_{11}\wedge\dots\wedge L_{1n_1})\vee\dots\vee(L_{k1}\wedge\dots\wedge L_{kn_k})$ where the "literals" are either propositional logic literals \ul{or} of the form $\square G$ or $\diamond G$ with a modal logic formula $G$.\\
Every modal logic formula is equivalent to a formula in QDNF.\\
\section{The Tableau Calculus of Propositional Logic}
\ul{The Tableau Completion Algorithm of Propositional Logic}: Let $F$ be a propositional logic formula. We construct recursively a binary tree $(K,N)$.
\begin{enumerate}[(1)]
	\item We put $F$ at the root of the tree. We mark each node which has been treated according to the following rules.
	\item Choose a node $G$ which has not yet been marked.\\
	Depending on the structure of $G$, apply one of the following \ul{tableau rules}. Then mark $G$ as treated. If all nodes have been marked, return the tree and stop. (This tree will be called a \ul{complete tableau}).
	\item If $G=\neg\neg H$ then append TODO at the end of each path starting at $G$.
	\item If $G=H_1\vee H_2$ then append TODO at the end of each path starting at $G$
	\item If $G=H_1\wedge H_2$ then append TODO at the end of each path starting at $G$.
	\item If $G=\neg (H_1\wedge H_2)$ then append TODO
	\item If $G=\neg (H_1\vee H_2)$ then append TODO
\end{enumerate}
Let $T=(K,N)$ be a tableau ($K$= set of nodes, $N$ successor relation)
\begin{enumerate}[(a)]
	\item A path in $T$ is called \ul{closed} if it contains both a proposition $A$ and its negation $\neg A$. In this case we mark the end of the path (usually a leaf) with $\lightning$
	\item The tableau $T$ is called \ul{closed} or \ul{contradictory} if all maximal paths (i.e. all paths starting at the root and ending in a leaf) are closed.
	\item The tableau $T$ is called \ul{satisfiable} if it is complete and there is a common mode for all nodes of a maximal path in $T$.
	\item Here the tableau is called \ul{complete} if every node is marked or a literal.
\end{enumerate}
Let $T$ be a tableau with root $F$.
\begin{enumerate}[(a)]
	\item If $T$ is closed then $F$ is unsatisfiable
	\item If $T$ is complete and satisfiable then $F$ is satisfiable
	\item The tableau completion algorithm computes a complete tableau
\end{enumerate}
\section{The Tableau Calculus of Modal Logic}
\ul{Modal Logic Tableau Completion Algorithm}:
\begin{enumerate}[(1)]
	\item The root of the tree is $S\Vdash F$ where $F$ is the given formula and $s$ the formal name of a state.
	\item Choose a node $\tilde s\Vdash G$ which has not yet been marked and where $G$ is not a propositional logic literal. If no such node exists, return the tableau.
	\item For a node of the form $\tilde s\Vdash \neg\neg G$, append TODO at the end of every path starting at this node. Similarly, treat $\tilde s\Vdash G\vee H$ and $\tilde s\Vdash G\wedge H$ and $\tilde s\Vdash \neg(G\vee H)$ and $\tilde s\Vdash\neg(G\wedge H)$ as in the propositional logic Tableau calculus.
	\item For a node of the form $\tilde s\Vdash \diamond G$, introduce a new symbol $t$ and append TODO at the end of every path starting at this node.
	\item For a node of the form $\tilde s\Vdash \square G$, append TODO at the end of every path starting at this node, where $t_1,\dots,t_k$ are all new symbols in this path for which $(\tilde s, t_i)\in R$.
	\item If the node is of the form $\tilde s\Vdash \neq\square H$, append TODO
	\item If the node is of the form $\tilde s\Vdash \neq\diamond H$, append TODO
\end{enumerate}
A maximal path in a (complete) tableau is \ul{closed} if it contains nodes $\tilde s\Vdash A$ and $\tilde s\Vdash\neg A$. The tableau is called \ul{closed} if all maximal paths are closed. The algorithm returns "UNSAT" if the completed tableau is closed.\\
\ul{Correctness of the Modal Logic Tableau Calculus}: In a complete tableau for $F$, mark all maximal paths as closed if they contain nodes of the form $\tilde s\Vdash A$ and $\tilde s\Vdash\neg A$. If the tableau is closed, i.e. if all maximal paths are closed, then $F$ is unsatisfiable.\\
\ul{Completeness of the Modal Logic Tableau Calculus}: If $F$ is unsatisfiable then the modal logic completion algorithm returns a closed tableau.
\end{document}






























