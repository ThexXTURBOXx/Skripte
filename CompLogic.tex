% !TeX spellcheck = en_US
\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz,tkz-euclide}
\usepackage{titlesec}
\usepackage{gensymb}
\usepackage{textcomp}
\usepackage[titles]{tocloft}
\usepackage{csquotes}
\usepackage[babel]{microtype}
\usepackage{MnSymbol}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{ulem}
\usepackage[shortlabels]{enumitem}
\usepackage{scalerel}
\usepackage{stackengine}
\usepackage[
  separate-uncertainty = true,
  multi-part-units = repeat
]{siunitx}

\usetkzobj{all}
\usetikzlibrary{shapes.misc}

\MakeOuterQuote{"}

\setcounter{secnumdepth}{4}

\renewcommand\hateq{\mathrel{\stackon[1.5pt]{=}{\stretchto{%
				\scalerel*[\widthof{=}]{\wedge}{\rule{1ex}{3ex}}}{0.5ex}}}}

\newcommand*\circled[1]{
  \tikz[baseline=(C.base)]\node[draw,circle,inner sep=0.75pt](C) {#1};\!
}

\newcommand*{\obot}{\perp\mkern-20.7mu\bigcirc}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\DeclarePairedDelimiter\norm{\lVert}{\rVert}
\makeatletter
\let\oldabs\abs
\def\abs{\@ifstar{\oldabs}{\oldabs*}}
\let\oldnorm\norm
\def\norm{\@ifstar{\oldnorm}{\oldnorm*}}
\makeatother

\renewcommand{\thesubsection}{\arabic{subsection}}
\titleformat{\section}{\normalfont\Large\bfseries}{§\arabic{section}: }{0em}{}
\titleformat{\subsection}{\normalfont\large\bfseries}{§\arabic{subsection} }{0em}{}
\titleformat{\subsubsection}{\normalfont\bfseries}{\arabic{subsection}.\arabic{subsubsection} }{0em}{}
\renewcommand{\cftsubsecpresnum}{§}
\newlength\mylength
\settowidth\mylength{\cftsubsecpresnum}
\settowidth\mylength{\cftsubsecaftersnum}
\addtolength\cftsubsecnumwidth{\mylength}
\renewcommand{\cftsecpresnum}{§}
\renewcommand{\cftsecaftersnum}{: }
\settowidth\mylength{\cftsecpresnum}
\addtolength\cftsecnumwidth{\mylength}

\newcommand{\ul}{\underline}
\renewcommand{\proof}{\ul{Beweis:}\\}
\renewcommand{\qed}{\begin{flushright}
\ul{\(q.e.d.\)}
\end{flushright}}
\let\origphi\phi
\let\phi\varphi
\let\origepsilon\epsilon
\let\epsilon\varepsilon

\title{Computational Logic}
\author{Nico Mexis}
\date{\today}

\begin{document}
\maketitle
\newpage

\tableofcontents
\newpage

\section{What is logic?}
\ul{Logical Statement:} Sentence/proposition, which evaluates to $TRUE$ or $FALSE$\\
\ul{Logical connectives:} If $A$ and $B$ are logical statements, then $A\wedge B$ is another one\\
\ul{Logical system:}
\begin{enumerate}[(1)]
	\item \ul{Syntax:}
	\begin{itemize}
		\item Atomic formulas are connected by operations
		\item There is a set of rules, which tell you, if the formula is well-formed
	\end{itemize}
	\item \ul{Semantics:}
	\begin{itemize}
		\item There is a set of rules, which tell you, how to assign truth values to formulas, given the values of the atomic formulas
	\end{itemize}
	\item \ul{Logical calculus:}
	\begin{itemize}
		\item Always $TRUE$: Tautology
		\item Always $FALSE$: Unsatisfiable
		\item Sometimes $TRUE$: Satisfiable
		\item There is a set of rules such that, given a formula $F$ and an assignment for the truth values of the atomic formulas, it calculates the truth value of $F$.
		\item The algorithm should be able to decide if $F$ is a tautology/satisfiable
	\end{itemize}
\end{enumerate}
\section{Propositional Logic}
\ul{Syntax}:
Atomic formulas are called \ul{propositions} denoted by $A_0,A_1,\dots$ (or $A,B,C,\dots$)\\
A \ul{formula} in propositional logic is obtained by recursively applying the following rules:
\begin{enumerate}[(1)]
	\item An atomic formula is a formula
	\item Given a formula $F$, also $\neg F$ is a formula ("not $F$")
	\item Given two formulas $F,G$, also $F\wedge G$ ("$F$ and $G$") and $F\vee G$ ("$F$ or $G$") are formulas
\end{enumerate}
Let $F,G$ be formulas.
\begin{enumerate}[(a)]
	\item Instead of $\neg F\vee G$, we also write $F\Rightarrow G$ ("$F$ implies $G$")
	\item Instead of $(\neg F\vee G)\wedge (F\vee \neg G)$ we also write $F\Leftrightarrow G$ ("$F$ is equivalent to $G$")
	\item Instead of $F_1\wedge\dots\wedge F_n$ we also write $\bigwedge_{i=1}^n F_i$ and instead of $F_1\vee\dots\vee F_n$ also $\bigvee_{i=1}^n F_i$
\end{enumerate}
\ul{Semantics}:
\begin{enumerate}[(a)]
	\item The set of truth values is $\{0,1\}$, where 0 is $FALSE$ and 1 is $TRUE$
	\item Let $M$ be a set of atomic formulas. A map $\alpha:M\rightarrow\{0,1\}$ is called a \ul{truth assignment}
	\item Let $\hat{M}$ be the set of all formulas in which only propositions of $M$ appear.\\
	Then we define $\hat{\alpha}:\hat{M}\rightarrow\{0,1\}$ recursively as follows:
	\begin{enumerate}[(1)]
		\item If $A\in M$, then we let $\hat{\alpha}(A)=\alpha(A)$
		\item If $\alpha(F)$ is defined, then we let $\hat{\alpha}(\neg F)=1-\hat{\alpha}(F)$
		\item Given formulas $F,G$ for which $\hat{\alpha}(F),\hat{\alpha}(G)$ have been defined, we let $\hat{\alpha}(F\wedge G)=\begin{cases}
		1, & \text{if } \hat{\alpha}(F)=\hat{\alpha}(G)=1\\
		0, & \text{otherwise}
		\end{cases}$ and $\hat{\alpha}(F\vee G)=\begin{cases}
		1, & \text{if } \hat{\alpha}(F)=1 \text{ or } \hat{\alpha}(G)=1 \text{ or both}\\
		0, & \text{if } \hat{\alpha}(F)=\hat{\alpha}(G)=1
		\end{cases}$
	\end{enumerate}
\end{enumerate}
\begin{tabular}{ll}
$F$ "if" $G$ & $\hateq$ $G\Rightarrow F$\\
$F$ "only if" $G$ & $\hateq$ $F\Rightarrow G$\\
$F$ "if and only if" $G$ & $\hateq$ $F\Leftrightarrow G$\\
\end{tabular}\\
Let $F$ be a (propositional logic) formula, $M$ a set of propositions and $\alpha:M\rightarrow\{0,1\}$ a truth assignment.
\begin{enumerate}[(a)]
	\item The formula $F$ \ul{fits} with $\alpha$ or $\alpha$ is \ul{suitable} for $F$ if in $F$ only the propositions from $M$ appear.
	\item If $\alpha(F)=1$, then $F$ is called a \ul{model} for $\alpha$. We write $\alpha\models F$.
	\item Given a set of formulas $\mathcal{F}$, we write $\alpha\models \mathcal{F}$ if $\alpha\models F$ for every $F\in\mathcal{F}$.
	\item We say that $F$ is \ul{satisfiable} if there exists a truth assignment $\alpha$, which is suitable for $F$ and if $\alpha(F)=1$. Otherwise, we say that $F$ is \ul{unsatisfiable}.
	\item A formula $F$ is called a \ul{tautology} (or \ul{valid}) if $\alpha(F)=1$ for every suitable truth assignment $\alpha$.
\end{enumerate}
A formula $F$ is a \ul{tautology} if and only if $\neg F$ is unsatisfiable.\\
Two formulas $F,G$ are called \ul{(semantically) equivalent}, if for all truth assignments $\alpha$, which are suitable for both $F$ and $G$, we have $\alpha(F)=\alpha(G)$. Notation: $F\equiv G$\\
\ul{The Fundamental Equivalences:}
Let $F,G,H$ be formulas.
\begin{enumerate}[(a)]
	\item $F\wedge F\equiv F$ and $F\vee F\equiv F$ (idempotency)
	\item $F\wedge G\equiv G\wedge F$ and $F\vee G\equiv G\vee F$ (commutativity)
	\item $(F\wedge G)\wedge H\equiv F\wedge(G\wedge H)$ and\\
	$(F\vee G)\vee H\equiv F\vee (G\vee H)$ (associativity)\\
	Hence we write $F_1\wedge\dots\wedge F_n$ or $F_1\vee \dots\vee F_n$.
	\item $F\wedge(F\vee G)\equiv F$ and $F\vee(F\wedge G)\equiv F$ (absorption)
	\item $F\wedge(G\vee H)\equiv (F\wedge G)\vee(F\wedge H)$ and\\
	$F\vee(G\wedge H)\equiv (F\vee G)\wedge(F\vee H)$ (distributive law)
	\item $\neg$$\neg F\equiv F$
	\item $\neg(F\wedge G)\equiv \neg F\vee \neg G$ and\\
	$\neg(F\vee G)\equiv \neg F\wedge \neg G$ (de Morgan's rules)
	\item If $F$ is a tautology, then $F\vee G\equiv F$ and $F\wedge G\equiv G$
	\item If $F$ is unsatisfiable, then $F\vee G\equiv G$ and $F\wedge G\equiv F$
\end{enumerate}
\ul{Substitution Theorem}:\\
Let $F_1,F_2$ be two equivalent formulas.\\
Let $G$ be a formula, which contains $F_1$ as a subformula.\\
Let $\tilde{G}$ be the formula obtained by replacing $F_1$ in $G$ by $F_2$.\\
Then we have $G\equiv \tilde{G}$.
\begin{enumerate}[(a)]
	\item A \ul{literal} is an atomic formula or the negation of an atomic formula ($A_i$ or $\neg A_i$)
	\item A formula $F$ is said to be in \ul{conjunctive normal form} (CNF), if it is of the form $$F=(L_{11}\vee L_{12}\vee\dots\vee L_{1n_1})\wedge\dots\wedge(L_{k1}\vee L_{k2}\vee\dots\vee L_{kn_k})$$ where the $L_{ij}$ are literals ("$F$ is a conjunction of disjunctions of literals").
	\item We say that $F$ is in \ul{disjunctive normal form} (DNF) if $$F=(L_{11}\wedge L_{12}\wedge\dots\wedge L_{1n_1})\vee\dots\vee(L_{k1}\wedge L_{k2}\wedge\dots\wedge L_{kn_k})$$ with literals $L_{ij}$.
\end{enumerate}
\ul{Algorithm:}\\
Let $F$ be a formula. Consider the following sequence of instructions:
\begin{enumerate}[(1)]
	\item Replace all occurrences of "$\Rightarrow$" and "$\Leftrightarrow$" by their definition
	\item Replace each subformula of the form $\neg$$\neg G$ by $G$.
	\item Replace in $F$ every subformula of the form $\neg (G\vee H)$ by $\neg G\wedge \neg H$. If a subformula $\neg$$\neg K$ results, apply step (2).
	\item Replace in $F$ every subformula of the form $\neg (G\wedge H)$ by $\neg G\vee \neg H$. If a subformula $\neg$$\neg K$ results, apply step (2).
	\item Repeat (3) and (4) as often as possible.
	\item Replace in $F$ every subformula of the form $G\vee (H\wedge K)$ by $(G\vee H)\wedge (G\vee K)$
	\item Replace in $F$ every subformula of the form $(G\wedge H)\vee K$ by $(G\vee K)\wedge (H\vee K)$
	\item Repeat (6) and (7) as often as possible. Then return $F$ and stop.
\end{enumerate}
This is an algorithm, which returns a formula $\tilde{F}$ in CNF, such that $\tilde{F}\equiv F$.\\\\
\ul{Compactness Theorem}:\\
Let $\mathcal{F}$ be a countably infinite set of formulas. Then $\mathcal{F}$ is satisfiable iff every finite subset of $\mathcal{F}$ is satisfiable.\\\\
\ul{The Resolution Calculus}:\\
Assume, that $F$ is given in CNF. Write $F\equiv (L_{11}\vee\dots\vee L_{1n_1})\wedge\dots\wedge(L_{k1}\vee\dots\vee L_{kn_k})$ with literals $L_{ij}$.
\begin{enumerate}[(a)]
	\item The sets $\{L_{i1},L_{i2},\dots,L_{in_i}\}$ is called a \ul{clause} of $F$.
	\item The set $\mathcal{K}(F)=\{\{L_{11},\dots,L_{1n_1}\},\dots,\{L_{k1},\dots,L_{kn_k}\}\}$ is called the \ul{set of clauses} of $F$.
	\item Let $C_1,C_2$ be clauses. We say that a clause $C_3$ is a \ul{resolvent} of $C_1$ and $C_2$ if:
	\begin{enumerate}[(1)]
		\item There exists a literal $L\in C_1$ such that $\neg L\in C_2$ (Assume $\neg L\notin C_1,L\notin C_2$)
		\item $C_3=(C_1\backslash\{L\})\cup (C_2\backslash\{\neg L\})$
	\end{enumerate}
\end{enumerate}
$\lightning$ We may \ul{not} cancel two literals simultaneously!!!\\
\ul{Note}: If $C_3=\varnothing$ (i.e. if $C_1=\{L\}$ and $C_2=\{\neg L\}$), then $F$ is unsatisfiable.\\
A set of clauses $S$ is called unsatisfiable iff $\varnothing\in S$\\\\
\ul{The Resolution Lemma}\\
Let $\mathcal{K}(F)$ be the set of clauses of a formula $F$ in CNF. Let $C_1,C_2\in\mathcal{K}(F)$ and let $C_3$ be a resolvent of $C_1$ and $C_2$. Then $F$ is equivalent to every formula $\tilde{F}$ with $\mathcal{K}(\tilde{F})=\mathcal{K}(F)\cup\{C_3\}$.\\
Let $\mathcal{K}$ be a set of clauses.
\begin{enumerate}[(a)]
	\item We set $Res^0(\mathcal{K})=\mathcal{K}$\\
	$Res^1(\mathcal{K})=\mathcal{K}\cup\{C\ \vert\ C\text{ is a resolvent of two clauses in }\mathcal{K}\}$\\
	For $n\geq 2$ we let $Res^n(\mathcal{K})=Res^1(Res^{n-1}(\mathcal{K}))$
	\item We let $Res^\infty(\mathcal{K})=\bigcup_{n\geq 0}Res^n(\mathcal{K})$\\
	This is in fact a finite union since with finitely many atomic formulas $A_1,\dots,A_n$ in $\mathcal{K}$ we can format at most $4^n$ clauses.
\end{enumerate}
\ul{Resolution Theorem}:\\
A formula $F$ in CNF is unsatisfiable iff $\varnothing\in Res^\infty(\mathcal{K}(F))$.\\
Given a formula $F$, perform the following steps:
\begin{enumerate}[(1)]
	\item Bring $F$ into CNF and form $\mathcal{K}(F)$
	\item Calculate $Res^\infty (\mathcal{K}(F))$ by computing $Res^n(\mathcal{K}(F))$ until $Res^n(\mathcal{K}(F))=Res^{n+1}(\mathcal{K}(F))$. Then $F$ is unsatisfiable iff $\varnothing\in Res^\infty (\mathcal{K}(F))$.
\end{enumerate}
\section{Horn Logic}
Let $F$ be a propositional logic formula in CNF.\\
Write $F\equiv (L_{11}\vee\dots\vee L_{1m_1})\wedge\dots\wedge(L_{k1}\vee\dots\vee L_{km_k})$ with literals $L_{ij}$.
\begin{enumerate}[(a)]
	\item $F$ is called a \ul{Horn formula} if every disjunction $L_{i1}\vee\dots\vee L_{im}$ contains \ul{at most} one positive literal.
	\item A clause $\{L_{i1},\dots,L_{im_i}\}$ is called a \ul{Horn clause} if it contains at most one positive literal.
	\item The syntax of \ul{Horn logic} is the same as the syntax of propositional logic, except that we only allow Horn formulas.
\end{enumerate}
\begin{enumerate}[(a)]
	\item A Horn clause of the form $\{A_i\}$ is called a \ul{fact clause}.
	\item A Horn clause with a positive and at least one negative literal is called a \ul{procedural clause} or a \ul{rule}.
	\item A negative Horn clause (i.e. a Horn clause with no positive literal) is called a \ul{goal clause} or \ul{question clause}.
	\item A Horn clause containing a positive literal is called a \ul{program clause} or a \ul{definite clause}.
	\item A set of Horn clauses is called a \ul{logic program} or \ul{Horn clause program}.
\end{enumerate}
\ul{Marking algorithm}:\\
Suppose we are given a Horn formula $F$ (in CNF)
\begin{enumerate}[(1)]
	\item For every atomic formula $A$ which is in $\mathcal{K}(F)$ as a fact, we mark all appearances of $A$ and $\neg A$ in $F$.
	\item If $A_1,\dots,A_n$ have already been marked, then we check whether $F$ contains a clause of the following form: $\neg A_1\vee\neg A_2\vee\dots\vee\neg A_n\vee B$. In this case, we mark every occurrence of $B$ or $\neg B$ in $F$.
	\item Repeat (2) as often as possible.
	\item Check if $F$ contains a subformula $G$ of the form $\neg A_1\vee\dots\vee\neg A_l$ where all $A_1,\dots,A_l$ have been marked. In this case, we return "unsatisfiable" and stop the algorithm.
	\item Otherwise return "satisfiable".
\end{enumerate}
\ul{Then}:
\begin{enumerate}[(a)]
	\item This is an algorithm which decides whether $F$ is satisfiable or unsatisfiable
	\item If $F$ is satisfiable then we get a satisfying truth assignment by letting $\alpha(A_i)=\begin{cases}
	1, & \text{if }A_i\text{ has been marked}\\
	0, & \text{otherwise}
	\end{cases}$
	\item If $F$ contains $n$ atomic formulas, the algorithm stops after at most $n$ iterations of (2).
\end{enumerate}
The clause $\varnothing$ has a \ul{linear resolution} from a set of clauses $\mathcal{K}$ if there exists a clause $K_0\in\mathcal{K}(F)$ and a sequence of clauses $K_1,\dots,K_n$ with the following properties:
\begin{enumerate}[(a)]
	\item TODO GRAPH\\
	where the \ul{side clause} $B_{i-1}$ is either an element of $\mathcal{K}(F)$ or $B_{i-1}=K_0$ for some $j<i-1$
	\item $K_n=\varnothing$
\end{enumerate}
Then the sequence $K_0,K_1,\dots,K_n$ is called a \ul{linear resolution} of $F$.\\
Let $F$ be a formula in CNF. A linear resolution $K_0,K_1,\dots,K_n$ of $F$ is called an \ul{input resolution} if $B_i\in\mathcal{K}(F)$ for $i=0,1,\dots,n-1$\\
Let $F$ be a formula in CNF. An \ul{SLD-resolution} (linear resolution with unrestricted selection function for definite clauses) is an input resolution of the following form:
\begin{enumerate}[(a)]
	\item $K_0$ is a \ul{goal clause} (negative)
	\item For each resolution step, the parent clause $K_{i-1}$ is a non-negative Horn clause, i.e. program clause
\end{enumerate}
Hence an SLD-resolution has the following shape:\\
Let $\mathcal{K}(F)=\{\underbrace{P_1,\dots,P_n}_{\text{program clauses}},\underbrace{N_1,\dots,N_K}_{\text{negative clauses (goals)}}\}$\\
TODO GRAPH (LECTURE 4)\\
Notice: An SLD-resolution needs a \ul{selection function} for the $B_i$. The choice is a key component of logic programming.\\
\begin{enumerate}[(a)]
	\item Linear resolution is \ul{complete} for propositional logic formulas in CNF i.e. if $F$ is unsatisfiable, then there exists a linear resolution which proves it.
	\item SLD resolution is complete for Horn formulas
\end{enumerate}
\ul{PROLOG Notation}:\\
Let $F$ be a Horn formula in CNF.
\begin{enumerate}[(a)]
	\item $\{A\}$ is denoted by \texttt{A.} or \texttt{A:-.}
	\item $\{A,\neg B,\dots,\neg C\}$ is denoted by \texttt{A:-B,\dots,C.}
	\item $\{\neg A,\dots,\neg B\}$ is denoted by \texttt{?-A,\dots,B.}
\end{enumerate}
\ul{SLD-Tree}:\\
TODO GRAPH (LECTURE 5)\\
There are 2 main strategies to work through the SLD tree:
\begin{enumerate}[(a)]
	\item breadth-first-strategy
	\item depth-first-strategy or canonical strategy (needs back-tracking)
\end{enumerate}
\begin{enumerate}[(a)]
	\item The breadth-first-strategy is complete for Horn formulas.
	\item The depth-first-strategy is \ul{not} complete.
\end{enumerate}
\section{Predicate logic}
\ul{Syntax of Predicate logic}
\begin{enumerate}[(a)]
	\item A \ul{variable} is a symbol of the form $x_i$, where $i\geq0$ (or $x,y,z$)
	\item A \ul{function symbol} is of the form $f_i^{(k)}$ where $i,k\in\mathbb{N}$. Here $i$ is used to distinguish different functions and $k$ denotes the \ul{arity} (=number of arguments of $f_i$), also: $f,g,h,\dots$
	\item A \ul{term} is constructed by recursively applying the following rules:
	\begin{enumerate}[(c1)]
		\item a variable is a term
		\item If $t_1,\dots,t_k$ are terms and $f_i^{(k)}$ is a $k$-ary function symbol, then $f_i^{(k)}(t_1,\dots,t_k)$ is a term
	\end{enumerate}
	\item A function $f_i^{(0)}$ is called a \ul{constant}. Notation for constants: $a_i$ or $a,b,c$
	\item A \ul{predicate symbol} (or \ul{relation symbol}) is of the form $P_i^{(k)}$ where $i,k\in\mathbb{N}$ and $k$ is the \ul{arity} (classical relations are 2-ary $\hateq$ binary). We also write $P,Q,R$
	\item An atomic formula of predicate logic is of the form $P_i^{(k)}(t_1,\dots,t_k)$ where $t_1,\dots,t_k$ are terms and $P_i^{(k)}$ is a $k$-ary predicate symbol.
	\item A \ul{(predicate logic) formula} is recursively constructed using the following rules:
	\begin{enumerate}[(g1)]
		\item An atomic formula is a formula
		\item We have the connectives $\wedge,\vee,\neg$. So, $\neg F$, $F\wedge G$, \dots are defined for formulas $F,G$.
		\item Given a variable $x$ and a formula $F$, also $\forall x:F$ is a formula. $\forall$ is called the \ul{universal quantifier}.
		\item Given a variable $x$ and a formula $F$, also $\exists x:F$ is a formula. $\exists$ is called the \ul{existential quantifier}.
	\end{enumerate}
\end{enumerate}
\ul{Definitions}:
\begin{enumerate}[(a)]
	\item A \ul{subformula} of predicate logic formula $F$ is a formula contained in the iterative construction of $F$.
	\item A variable $x$ in a subformula $\forall x:G$ or $\exists x:G$ is called \ul{bound}.
	\item If $x$ is a variable which is not bound in a subformula, then $x$ is called a \ul{free} variable.
	\item If all variables in a formula $F$ are bound, then $F$ is called \ul{closed} (or a predicate logic proposition)
	\item If we delete all $\forall x_i,\exists x_i$ in a formula $F$, we get its \ul{matrix formula} $F^*$.
\end{enumerate}
\ul{Structures}:
\begin{enumerate}[(a)]
	\item A \ul{structure} $\alpha=(U,\phi,\psi,\xi)$ consists of the following parts:
	\begin{enumerate}[(\text{a}1)]
		\item $U$ is a set called the \ul{universe} (or the \ul{domain})
		\item $\phi$ is a map, which assigns to each function symbol $f_i^{(k)}$ a map: $\phi(f_i^{(k)}):U^k\rightarrow U$
		\item $\psi$ is a map, which assigns to each predicate $P_i^{(k)}$ a subset $\psi(P_i^{(k)})\subseteq U^k$
		\item $\xi$ is a map, which assigns to each variable $x_i$ an element $\xi(x_i)\in U$
	\end{enumerate}
	\item Let $\alpha=(U,\phi,\psi,\xi)$ be a structure. For every term $t$, we define a value $\alpha(t)\in U$ recursively as follows:
	\begin{enumerate}[(b1)]
		\item If $t=x_i$ is a variable, we let $\alpha(t)=\xi(x_i)$
		\item If $t=f_i^{(k)}(\tilde t_1,\dots,\tilde t_k)$, where $\alpha(\tilde t_1),\dots,\\alpha(\tilde t_k)\in U$ are already defined, we let $\alpha(t)=\phi(f_i^{(k)})(\alpha(t_1),\dots,\alpha(\hat t_k))\in U$
	\end{enumerate}
	\item Given a structure $\alpha=(U,\phi,\psi,\xi)$ and a formula $F$, we define a truth value $\alpha(F)\in\{0,1\}$ recursively as follows:
	\begin{enumerate}[(c1)]
		\item If $F=P_i^{(k)}(t_1,\dots,t_k)$ with terms $t_1,\dots,t_k$ we let $\alpha(P_i^{(k)}(t_1,\dots,t_k))=\begin{cases}
		1 & \text{if }(\alpha(t_1),\dots,\alpha(t_k))\in\psi(P_i^{(k)})\\
		0 & \text{otherwise}
		\end{cases}$
		\item The values $\alpha(\neg F)$, $\alpha(F\vee G)$, $\alpha(F\wedge G)$ are defined as in propositional logic
		\item If $F$ is of the form $\forall x:G$ then we define for every $u\in U$ a structure $\tilde\alpha_u=(U,\phi,\psi,\tilde\xi_u)$ where $\tilde\xi_u(x)=u$ and $\tilde\xi_u(y)=\xi(y)$ for all other variables. Then we define $\alpha(\forall x, G)=\begin{cases}
		1 & \text{if } \tilde\alpha_u(G)=1 \text{ for all } u\in U\\
		0 & \text{otherwise}
		\end{cases}$
		\item If $F$ is of the form $F=\exists x : G$ then we define the structures $\tilde\alpha_u$ for $u\in U$ as in (c3) and let $\alpha(\exists x:G)=\begin{cases}
		1 & \text{if } \tilde\alpha_u(G)=1 \text{ for some } u\in U\\
		0 & \text{otherwise}
		\end{cases}$
	\end{enumerate}
\end{enumerate}
Let $F$, $G$ be formulas.
\begin{enumerate}[(a)]
	\item A structure $\alpha=(U,\phi,\psi,\xi)$ is called \ul{suitable} for $F$ if all variables, function symbols and predicates appearing in $F$ are assigned values in $\alpha$
	\item $\alpha$ is called a \ul{model} for $F$ if $\alpha(F)=1$. We write $\alpha\models F$
	\item $F$ is called a \ul{tautology} or \ul{valid} if $\alpha\models F$ for every suitable $\alpha$
	\item $F$ is called \ul{unsatisfiable} if $\alpha(F)=0$ for every suitable $\alpha$
\end{enumerate}
The logical system we just defined is called \ul{first order predicate logic}.\\
Propositional logic can be embedded into predicate logic:
\begin{itemize}
	\item we allow no variables, no functions and only 0-ary predicates $P_i^{(0)}$; moreover we don't allow quantifiers
	\item we interpret $P_i^{(0)}=A_i$ as propositions and let $\alpha(A_i)\hateq\psi(P_i^{(0)})=\begin{cases}
	\{\}\\
	\{\varnothing\}
	\end{cases}$ via $\alpha(A_i)=\begin{cases}
	0 & \text{if }\psi(P_i^{(0)})=\{\}\\
	1 & \text{if }\psi(P_i^{(0)})=\{\varnothing\}
	\end{cases}$ for some structure $\alpha=(U,\phi,\psi,\xi)$ where $U=\{0,1\}$
\end{itemize}
\ul{Definitions}:
\begin{enumerate}[(a)]
	\item Two formulas $F$, $G$ are called \ul{equivalent} if $\alpha(F)=\alpha(G)$ for every structure $\alpha=(U,\phi,\psi,\xi)$ which is suitable for both $F$ and $G$
	\item  A formula $F$ is said to be in \ul{prenex form} if $F=Q_1x_{i_1}:Q_2x_{i_2}:\dots:Q_kx_{i_k}:G$ such that $Q_1,\dots,Q_k$ are quantifiers and $x_{i_j}$ variables and $G$ is quantifier-free
\end{enumerate}
\ul{Fundamental equivalences}:
\begin{enumerate}[(a)]
	\item All fundamental equivalences of propositional logic still hold
	\item $\neg(\forall x:F)\equiv (\exists x:\neg F)$\\
	$\neg(\exists x:F)\equiv (\forall x:\neg F)$
	\item $(\forall x : F)\wedge (\forall x : G)\equiv \forall x : (F\wedge G)$\\
	$(\exists x : F)\vee (\exists x : G)\equiv \exists x : (F\vee G)$
	\item $\forall x:\forall y: F\equiv\forall y:\forall x:F$\\
	$\exists x:\exists y: F\equiv\exists y:\exists x:F$
	\item If $H$ does not contain $x$, then\\
	$(\forall x: F)\wedge H\equiv \forall x:(F\wedge H)$\\
	$(\forall x: F)\vee H\equiv \forall x:(F\vee H)$\\
	$(\exists x: F)\wedge H\equiv \exists x:(F\wedge H)$\\
	$(\exists x: F)\vee H\equiv \exists x:(F\vee H)$\\
\end{enumerate}
Let $F$ be a formula, let $x$ be a variable which appears in $F$, and let $t$ be a term.
\begin{enumerate}[(a)]
	\item If $x$ appears freely in $F$, we replace every occurrence of $x$ by $t$ we get a new formula $F\vert_{x\mapsto t}$ which is called the \ul{substitution} of $x$ by $t$
	\item We can also substitute bound variables $x$, but only by other variables. $\forall x:F\rightarrow \forall y:F\vert_{x\mapsto y}$. This is called a \ul{bound substitution} or \ul{bound variable renaming}
\end{enumerate}
\ul{Cleaned form of a Predicate Logic Formula}: Given a formula $F$, the following step brings it to \ul{cleaned form:} Use bound substitutions to make the names of bound variables pairwise distinct with free variables. The result is called the \ul{cleaned form} of $F$.\\
Using bound renamings $\forall x : F\equiv \forall y : F\vert_{x\mapsto y}$, we can make all bound variables pairwise distinct and distinct with the free variable names.\\
\ul{Transformation to Prenex Form}: The following instructions define an algorithm which transforms a given formula $F$ to an equivalent formula $G$ such that $G$ is in cleaned Prenex form.
\begin{enumerate}[(1)]
	\item Replace $F$ by an equivalent formula in cleaned form
	\item If $F$ is an atomic formula then return $F$ and stop
	\item If $F$ is of the form $F=\neg \tilde F$, then apply the algorithm to $\tilde F$ and get $\tilde Q_1x_{i_1}:\dots:\tilde Q_kx_{i_k}:H$ with quantifiers $\tilde Q_1,\dots,\tilde Q_k$ and a quantifier-free formula $H$. Then return $\hat Q_1x_{i_1}:\dots:\hat Q_{i_k}:\neg H$ where $\hat Q_i=\exists$ if $\tilde Q_i=\forall$ and $\hat Q_i=\forall$ if $\tilde Q_i=\exists$
	\item If $F$ is of the form $F=G\vee H$ then apply the algorithm to $G$ and $H$ and get $G\equiv \tilde Q_1x_{i_1}:\dots:\tilde Q_kx_{i_k}:\tilde G$ and $H\equiv \hat Q_1y_1\dots \hat Q_ly_l:\tilde H$ where $\tilde Q_i,\hat Q_j$ are quantifiers and $\tilde G, \tilde H$ are quantifier-free. Then return $\tilde Q_1x_{i_1}:\dots:\tilde Q_kx_{i_k}:\hat Q_1y_1:\dots\hat Q_ly_l:(\tilde G\vee \tilde H)$
	\item If $F=G\wedge H$ then apply the algorithm as in step (4) and return $\tilde Q_1x_{i_1}:\dots:\tilde Q_kx_{i_k}:\hat Q_1y_1:\dots\hat Q_ly_l:(\tilde G\wedge \tilde H)$
	\item If $F=\forall x:G$ resp. $F=\exists x:G$ then apply the algorithm to $G$ and get $G\equiv\tilde Q_1x_{i_1}:\dots:\tilde Q_kx_{i_k}:\tilde G$ where $\tilde Q_1,\dots,\tilde Q_k$ are quantifiers and $\tilde G$ is quantifier-free. Then return $\forall x:\tilde Q_1x_{i_1}:\dots:\tilde Q_kx_{i_k}:\tilde G$ (resp. $\exists x:\tilde Q_1x_{i_1}:\dots:\tilde Q_kx_{i_k}:\tilde G$) and stop.
\end{enumerate}
Two formulas $F,G$ are called \ul{satisfiability equivalent} if ($F$ is satisfiable iff $G$ is satisfiable)\\
\ul{The Skolem Form of a Prenex Formula}: Let $F$ be a formula in prenex form: $F=Q_1x_1:\dots:Q_kx_k:G$ where $Q_i$ are quantifiers and $G$ is quantifier free. The following algorithm produces a formula $G$ in prenex form such that $G$ is satisfiability equivalent to $F$ and $G$ contains only universal quantifiers:
\begin{enumerate}[(1)]
	\item If there exists an existential quantifier in $F$ then we write $\forall x_1:\forall x_2:\dots:\forall x_l:\exists x_{l+1}:H$ where $l\geq 0$ and $H$ is in prenex form. Let $f_i^{(k)}$ be a $k$-ary function symbol not used in $F$. Then replace $F$ by the formula $\forall x_1:\dots:x_l:H$, $x_{l+1}\mapsto f_i^{(l)}(x_1,\dots,x_l)$
	\item Repeat Step (1) as often as possible
	\item Return the resulting formula $G$. It is said to be in Skolem form or a \ul{Skolemization} of $F$.
\end{enumerate}
\ul{Löwenhain-Skolem}: Every cleaned prenex formula is satisfiability equivalent to one having only universal quantifiers. More precisely, for $F=\forall x_1:\dots:\forall x_l:\exists x_{l+1}:H$, where $H$ is in cleaned prenex form, we let $f_1^{(l)}$ be a new function symbol. Then $F$ is satisfiability equivalent to  $G=\forall x_1:\dots:\forall x_l:H\vert_{x_{l+1}\mapsto f_i^{(l)}(x_1,\dots,x_l)}$\\
\ul{Matrix Clause Form}: Let $F$ be a predicate logic formula. Apply the following instructions:
\begin{enumerate}[(1)]
	\item Transform $F$ into an equivalent formula $G$ in cleaned prenex form
	\item Let $y_1,\dots,y_m$ be the free variables in $G$. Replace $G$ by $\tilde G=\exists y_1:\exists y_2:\dots:\exists y_m:G$
	\item Compute the Skolem form of $\tilde G$ and get $H=\forall x_1:\dots:\forall x_l:H^*$, $H^*$ matrix formula of $H$ (quantifier-free, no free variables)
	\item Calculate the CNF of $H^*$ where we consider atomic formulas like "propositions". Call the result $\tilde F$.
	\item Return the set $\mathcal{K}(\tilde F)$
\end{enumerate}
Then $F$ is satisfiability equivalent to $\tilde F$ and $\mathcal{K}(\tilde F)$ is satisfiable \ul{iff} $F$ is satisfiable.\\
\ul{Church's Theorem}: There is no algorithm which decides in finitely many steps whether a given predicate logic formula is satisfiable or not.\\
\ul{Goals}:
\begin{enumerate}[(1)]
	\item Find the "smallest" universe in which $F$ could have a model
	\item If $F$ is unsatisfiable, can we prove it in finitely many steps?
\end{enumerate}
Assume, that $F$ is in matrix-clause form.
Let $D(F)$ be the set of all variable-free terms in the function symbols appearing in $F$. If $F$ contains no constant, then introduce the constant $a$. This set $D(F)$ can be constructed recursively as follows:
\begin{enumerate}[(1)]
	\item All constants are in $D(F)$.
	\item If $f_i^{(k)}$ is a $k$-ary function symbol and $t_1,\dots,t_k\in D(F)$, then $f_i^{(k)}(t_1,\dots,t_k)\in D(F)$.\\
	The set $D(F)$ is called the \ul{Herbrand universe} of $F$
\end{enumerate}
A structure $\alpha=(U,\phi,\psi,\xi)$ is called a \ul{Herbrand structure} if:
\begin{enumerate}[(1)]
	\item $U=D(F)$
	\item If $f_i^{(k)}$ is a $k$-ary function symbol in $F$ and $t_1,\dots,t_k\in D(F)$, then $\phi(f_i^{(k)}):\underset{(t_1,\dots,t_k)\mapsto f_i^{(k)}(t_1,\dots,t_k)}{U^k\rightarrow U=D(F)}$\\
	Hence $\alpha(f_i^{(k)}(t_1,\dots,t_k))=f_i^{(k)}(t_1,\dots,t_k)\in U$
\end{enumerate}
A Herbrand structure $\alpha=(U,\phi,\psi,\xi)$ for $F$ s.t. $\alpha\models F$ is called a \ul{Herbrand model} for $F$.\\
\ul{Löwenhain-Skolem}: Let $F$ be in matrix clause form. Then $F$ is satisfiable iff $F$ has a Herbrand model. In particular, if $F$ has a model, then it has a model with a countable universe.\\
Let $F$ be in matrix clause form: $F=\forall x_1:\dots:\forall x_n:F^*$. The \ul{Herbrand expansion} of $F$ is the following countably infinite set of formulas: $E(F)=\{F^*\vert_{x_1\mapsto t_1,\dots,x_n\mapsto t_n}:t_1,\dots,t_n\in D(F)\}$\\
\ul{Herbrand-Skolem-Gödel}: A closed formula $F$ in Skolem form is satisfiable, iff $E(F)$ is satisfiable (in the sense of propositional logic).\\
\ul{Basic Resolution Algorithm}: Given a predicate logic formula $F$, perform the following steps:
\begin{enumerate}[(1)]
	\item Transform $F$ (using satisfiability equivalence) to the form $F=\forall x_1:\dots:\forall x_n:G$ (as above)
	\item Let $M=\varnothing$ and $i=0$
	\item Increase $i$ by 1. Compute the next element $H_i$ of $E(F)$.\\
	Let $M=\{H_1,\dots,H_i\}$.
	\item Consider $M$ as a set of propositional logic formulas. Check if $M$ is unsatisfiable. If "True", then return "$F$ is unsatisfiable" and stop. Otherwise continue with (3).
\end{enumerate}
This is a procedure. If $F$ is unsatisfiable, it stops after finitely many steps and returns "$F$ is unsatisfiable". If $F$ is satisfiable, it produces an infinite loop.\\

\end{document}






























